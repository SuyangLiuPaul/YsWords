
================================================================================
FILE: pubspec.yaml
================================================================================
name: yswords
description: "YsWords means Yahweh's words. A bilingual Bible app to help you listen to His voice and abide in Him daily."
publish_to: 'none'
version: 0.1.0

environment:
  sdk: '>=3.2.3 <4.0.0'

dependencies:
  clipboard: ^0.1.3
  expandable: ^5.0.1
  flutter:
    sdk: flutter
  fluttertoast: ^8.2.12
  get: ^4.6.6
  provider: ^6.1.1
  scroll_to_index: ^3.0.1
  scrollable_positioned_list: ^0.3.8
  shared_preferences: ^2.5.3
  google_fonts: ^6.2.1
  cupertino_icons: ^1.0.2
  draggable_scrollbar: ^0.1.0
  url_launcher: ^6.3.1
  intl: ^0.20.2
  universal_html: ^2.2.4

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  flutter_launcher_icons: ^0.14.3

flutter:
  uses-material-design: true
  assets:
    - assets/kjv.json
    - assets/leb.json
    - assets/cuvs-yhwh.json
    - assets/cuvs-yhwh-tr.json
    - assets/biblexg.json
    - assets/biblexg-tr.json
    - assets/app_icon.png
    - assets/loading.png
    - assets/fonts/
  fonts:
    - family: Roboto
      fonts:
        - asset: assets/fonts/Roboto-VariableFont_wdth,wght.ttf
    - family: Microsoft YaHei
      fonts:
        - asset: assets/fonts/Microsoft Yahei.ttf

# Note:
# For Flutter Web, the browser tab icon (favicon) is located at:
# web/favicon.png
# You may need to manually replace or symlink it using:
# ln -sf ../assets/app_icon.png web/favicon.png

flutter_icons:
  image_path: "assets/app_icon.png"
  android:
    generate: true
  ios:
    generate: true
  macos:
    generate: true
  windows:
    generate: true
  linux:
    generate: true
  web:
    generate: true
    image_path: "assets/app_icon.png"


================================================================================
FILE: main.dart
================================================================================
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:yswords/pages/loading_page.dart';
import 'package:yswords/providers/main_provider.dart';
import 'package:yswords/models/app_settings.dart';
import 'package:yswords/services/fetch_books.dart';
import 'package:yswords/services/fetch_verses.dart';
import 'package:provider/provider.dart';
import 'package:get/get.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();

  FlutterError.onError = (FlutterErrorDetails details) {
    FlutterError.dumpErrorToConsole(details);
    PlatformDispatcher.instance.onError = (e, st) {
      print('UNCAUGHT: $e\n$st');
      return true;
    };
  };

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => MainProvider()),
        ChangeNotifierProvider(create: (context) => AppSettings()),
      ],
      child: const MainApp(),
    ),
  );
}

class MainApp extends StatefulWidget {
  const MainApp({super.key});

  @override
  State<MainApp> createState() => _MainAppState();
}

class _MainAppState extends State<MainApp> {
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    Timer(Duration(seconds: 8), () {
      if (_loading) {
        setState(() {
          _loading = false; // Optionally handle timeout behavior here.
        });
      }
    });
    Future.microtask(() async {
      final mainProvider = Provider.of<MainProvider>(context, listen: false);
      final appSettings = Provider.of<AppSettings>(context, listen: false);

      // Load settings and Bible content
      await appSettings.loadSettings();

      bool localResourcesReady = await FetchVerses.testLoadLocal();
      if (!localResourcesReady) {
        // If updates are disabled but no local data exists, fetch once to populate it:
        if (!appSettings.allowUpdates) {
          await FetchVerses.execute(
            mainProvider: mainProvider,
            settings: appSettings,
          );
          // recheck
          localResourcesReady = await FetchVerses.testLoadLocal();
        }
        appSettings.setLockAllowUpdates(true);
      } else {
        appSettings.setLockAllowUpdates(false);
      }

      await mainProvider.restoreState();

      if (mainProvider.verses.isEmpty) {
        if (appSettings.allowUpdates) {
          await FetchVerses.execute(
            mainProvider: mainProvider,
            settings: appSettings,
          );
        } else {
          await FetchVerses.loadLocalOnly(
            mainProvider: mainProvider,
          );
        }
      }

      await FetchBooks.execute(
          mainProvider: mainProvider, settings: appSettings);

      // Validate restored state or fallback
      if (mainProvider.currentBook != null &&
          mainProvider.currentChapter != null &&
          mainProvider.verses.any((v) =>
              v.book == mainProvider.currentBook &&
              v.chapter == mainProvider.currentChapter)) {
        final match = mainProvider.verses.firstWhere(
          (v) =>
              v.book == mainProvider.currentBook &&
              v.chapter == mainProvider.currentChapter,
        );
        mainProvider.updateCurrentVerse(verse: match);
      } else if (mainProvider.verses.isNotEmpty) {
        final firstVerse = mainProvider.verses.first;
        mainProvider.setCurrentChapter(
            book: firstVerse.book, chapter: firstVerse.chapter);
        mainProvider.updateCurrentVerse(verse: firstVerse);
      }

      setState(() {
        _loading = false;
      });
    });
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<AppSettings>(
      builder: (context, settings, _) {
        return GetMaterialApp(
          debugShowCheckedModeBanner: false,
          themeMode: settings.themeMode,
          theme: ThemeData(
            fontFamily: settings.fontFamily,
            fontFamilyFallback: ['Roboto', 'Arial', 'Helvetica'],
            textTheme: ThemeData.light().textTheme.copyWith(
                  bodyLarge: ThemeData.light().textTheme.bodyLarge?.copyWith(
                        fontFamily: settings.fontFamily,
                        fontSize: settings.fontSize,
                      ),
                  bodyMedium: ThemeData.light().textTheme.bodyMedium?.copyWith(
                        fontFamily: settings.fontFamily,
                        fontSize: settings.fontSize - 2,
                      ),
                  titleLarge: ThemeData.light().textTheme.titleLarge?.copyWith(
                        fontFamily: settings.fontFamily,
                        fontSize: settings.fontSize + 4,
                      ),
                ),
            colorSchemeSeed: settings.primaryColor,
          ),
          darkTheme: ThemeData(
            fontFamily: settings.fontFamily,
            fontFamilyFallback: ['Roboto', 'Arial', 'Helvetica'],
            textTheme: ThemeData.dark().textTheme.copyWith(
                  bodyLarge: ThemeData.dark().textTheme.bodyLarge?.copyWith(
                        fontFamily: settings.fontFamily,
                        fontSize: settings.fontSize,
                        color: Color(0xFFCCCCCC),
                      ),
                  bodyMedium: ThemeData.dark().textTheme.bodyMedium?.copyWith(
                        fontFamily: settings.fontFamily,
                        fontSize: settings.fontSize - 2,
                        color: Color(0xFFCCCCCC),
                      ),
                  titleLarge: ThemeData.dark().textTheme.titleLarge?.copyWith(
                        fontFamily: settings.fontFamily,
                        fontSize: settings.fontSize + 4,
                        color: Color(0xFFCCCCCC),
                      ),
                ),
            inputDecorationTheme: InputDecorationTheme(
              enabledBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF888888)),
              ),
              focusedBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: Color(0xFFCCCCCC), width: 2),
              ),
              hintStyle: TextStyle(color: Color(0xFFAAAAAA)),
            ),
            colorScheme: const ColorScheme.dark(
              surface: Color(0xFF1A1A1A),
              background: Color(0xFF121212),
              primary: Color(0xFFCCCCCC),
              onPrimary: Colors.black,
              onSurface: Color(0xFFCCCCCC),
            ),
            scaffoldBackgroundColor: Color(0xFF121212),
            cardColor: const Color(0xFF1A1A1A),
            cardTheme: CardTheme(
              color: Color(0xFF1F1F1F),
              elevation: 2,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
            appBarTheme: const AppBarTheme(
              backgroundColor: Color(0xFF121212),
              foregroundColor: Color(0xFFCCCCCC),
            ),
            sliderTheme: const SliderThemeData(
              inactiveTrackColor: Color(0xFF424242),
            ),
            elevatedButtonTheme: ElevatedButtonThemeData(
              style: ElevatedButton.styleFrom(
                backgroundColor: Color(0xFF333333),
                foregroundColor: Color(0xFFCCCCCC),
              ),
            ),
            textButtonTheme: TextButtonThemeData(
              style: TextButton.styleFrom(
                foregroundColor: Color(0xFFCCCCCC),
              ),
            ),
            outlinedButtonTheme: OutlinedButtonThemeData(
              style: OutlinedButton.styleFrom(
                foregroundColor: Color(0xFFCCCCCC),
                side: BorderSide(color: Color(0xFFCCCCCC)),
              ),
            ),
            dialogTheme: DialogTheme(
              backgroundColor: Color(0xFF1E1E1E),
              titleTextStyle: TextStyle(
                color: Color(0xFFCCCCCC),
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
              contentTextStyle: TextStyle(
                color: Color(0xFFCCCCCC),
                fontSize: 16,
              ),
            ),
            snackBarTheme: SnackBarThemeData(
              backgroundColor: Color(0xFF2C2C2C),
              contentTextStyle: TextStyle(
                color: Color(0xFFCCCCCC),
                fontSize: 14,
              ),
            ),
            dividerColor: Color(0xFF424242),
            iconTheme: const IconThemeData(
              color: Color(0xFFCCCCCC),
            ),
          ),
          builder: (context, child) {
            return ScrollConfiguration(
              behavior:
                  const MaterialScrollBehavior().copyWith(scrollbars: true),
              child: child!,
            );
          },
          home: _loading
              ? const Scaffold(
                  body: Center(
                    child: CircularProgressIndicator(),
                  ),
                )
              : LoadingPage(
                  verses:
                      Provider.of<MainProvider>(context, listen: false).verses),
        );
      },
    );
  }
}


================================================================================
FILE: constants/book_groups.dart
================================================================================
/// Old Testament (English + Chinese Simplified + Chinese Traditional)
const oldTestamentBooks = <String>{
  // English
  'Genesis', 'Exodus', 'Leviticus', 'Numbers', 'Deuteronomy',
  'Joshua', 'Judges', 'Ruth', '1 Samuel', '2 Samuel',
  '1 Kings', '2 Kings', '1 Chronicles', '2 Chronicles',
  'Ezra', 'Nehemiah', 'Esther', 'Job', 'Psalms', 'Proverbs',
  'Ecclesiastes', 'Song of Solomon', 'Isaiah', 'Jeremiah',
  'Lamentations', 'Ezekiel', 'Daniel', 'Hosea', 'Joel', 'Amos',
  'Obadiah', 'Jonah', 'Micah', 'Nahum', 'Habakkuk',
  'Zephaniah', 'Haggai', 'Zechariah', 'Malachi',
  // Chinese Simplified + Traditional
  'Âàõ‰∏ñËÆ∞', 'Ââµ‰∏ñÁ¥Ä',
  'Âá∫ÂüÉÂèäËÆ∞', 'Âá∫ÂüÉÂèäË®ò',
  'Âà©Êú™ËÆ∞', 'Âà©Êú™Ë®ò',
  'Ê∞ëÊï∞ËÆ∞', 'Ê∞ëÊï∏Ë®ò',
  'Áî≥ÂëΩËÆ∞', 'Áî≥ÂëΩË®ò',
  'Á∫¶‰π¶‰∫öËÆ∞', 'Á¥ÑÊõ∏‰∫ûË®ò',
  'Â£´Â∏àËÆ∞', 'Â£´Â∏´Ë®ò',
  'Ë∑ØÂæóËÆ∞', 'Ë∑ØÂæóË®ò',
  'ÊííÊØçËÄ≥ËÆ∞‰∏ä', 'ÊííÊØçËÄ≥Ë®ò‰∏ä',
  'ÊííÊØçËÄ≥ËÆ∞‰∏ã', 'ÊííÊØçËÄ≥Ë®ò‰∏ã',
  'ÂàóÁéãÁ∫™‰∏ä', 'ÂàóÁéãÁ¥Ä‰∏ä',
  'ÂàóÁéãÁ∫™‰∏ã', 'ÂàóÁéãÁ¥Ä‰∏ã',
  'ÂéÜ‰ª£Âøó‰∏ä', 'Ê≠∑‰ª£Âøó‰∏ä',
  'ÂéÜ‰ª£Âøó‰∏ã', 'Ê≠∑‰ª£Âøó‰∏ã',
  '‰ª•ÊñØÊãâËÆ∞', '‰ª•ÊñØÊãâË®ò',
  'Â∞ºÂ∏åÁ±≥ËÆ∞', 'Â∞ºÂ∏åÁ±≥Ë®ò',
  '‰ª•ÊñØÂ∏ñËÆ∞', '‰ª•ÊñØÂ∏ñË®ò',
  'Á∫¶‰ºØËÆ∞', 'Á¥Ñ‰ºØË®ò',
  'ËØóÁØá', 'Ë©©ÁØá',
  'ÁÆ¥Ë®Ä',
  '‰º†ÈÅì‰π¶', 'ÂÇ≥ÈÅìÊõ∏',
  'ÈõÖÊ≠å',
  '‰ª•Ëµõ‰∫ö‰π¶', '‰ª•Ë≥Ω‰∫ûÊõ∏',
  'ËÄ∂Âà©Á±≥‰π¶', 'ËÄ∂Âà©Á±≥Êõ∏',
  'ËÄ∂Âà©Á±≥ÂìÄÊ≠å',
  '‰ª•Ë•øÁªì‰π¶', '‰ª•Ë•øÁµêÊõ∏',
  '‰ΩÜ‰ª•ÁêÜ‰π¶', '‰ΩÜ‰ª•ÁêÜÊõ∏',
  '‰ΩïË•øÈòø‰π¶', '‰ΩïË•øÈòøÊõ∏',
  'Á∫¶Áè•‰π¶', 'Á¥ÑÁè•Êõ∏',
  'ÈòøÊë©Âè∏‰π¶', 'ÈòøÊë©Âè∏Êõ∏',
  '‰øÑÂ∑¥Â∫ï‰∫ö‰π¶', '‰øÑÂ∑¥Â∫ï‰∫ûÊõ∏',
  'Á∫¶Êãø‰π¶', 'Á¥ÑÊãøÊõ∏',
  'Âº•Ëø¶‰π¶', 'ÂΩåËø¶Êõ∏',
  'ÈÇ£È∏ø‰π¶', 'ÈÇ£È¥ªÊõ∏',
  'ÂìàÂ∑¥Ë∞∑‰π¶', 'ÂìàÂ∑¥Ë∞∑Êõ∏',
  'Ë•øÁï™ÈõÖ‰π¶', 'Ë•øÁï™ÈõÖÊõ∏',
  'ÂìàËØ•‰π¶', 'ÂìàË©≤Êõ∏',
  'ÊííËø¶Âà©‰∫ö‰π¶', 'ÊííËø¶Âà©‰∫ûÊõ∏',
  'ÁéõÊãâÂü∫‰π¶', 'Áë™ÊãâÂü∫Êõ∏',
};

/// New Testament (English + Chinese Simplified + Chinese Traditional)
const newTestamentBooks = <String>{
  // English
  'Matthew', 'Mark', 'Luke', 'John', 'Acts', 'Romans',
  '1 Corinthians', '2 Corinthians', 'Galatians', 'Ephesians',
  'Philippians', 'Colossians', '1 Thessalonians', '2 Thessalonians',
  '1 Timothy', '2 Timothy', 'Titus', 'Philemon', 'Hebrews',
  'James', '1 Peter', '2 Peter', '1 John', '2 John', '3 John',
  'Jude', 'Revelation',
  // Chinese Simplified + Traditional
  'È©¨Â§™Á¶èÈü≥', 'È¶¨Â§™Á¶èÈü≥',
  'È©¨ÂèØÁ¶èÈü≥', 'È¶¨ÂèØÁ¶èÈü≥',
  'Ë∑ØÂä†Á¶èÈü≥',
  'Á∫¶Áø∞Á¶èÈü≥', 'Á¥ÑÁø∞Á¶èÈü≥',
  '‰ΩøÂæíË°å‰º†', '‰ΩøÂæíË°åÂÇ≥',
  'ÁΩóÈ©¨‰π¶', 'ÁæÖÈ¶¨Êõ∏',
  'Âì•ÊûóÂ§öÂâç‰π¶', 'Âì•ÊûóÂ§öÂâçÊõ∏',
  'Âì•ÊûóÂ§öÂêé‰π¶', 'Âì•ÊûóÂ§öÂæåÊõ∏',
  'Âä†ÊãâÂ§™‰π¶', 'Âä†ÊãâÂ§™Êõ∏',
  '‰ª•ÂºóÊâÄ‰π¶', '‰ª•ÂºóÊâÄÊõ∏',
  'ËÖìÁ´ãÊØî‰π¶', 'ËÖìÁ´ãÊØîÊõ∏',
  'Ê≠åÁΩóË•ø‰π¶', 'Ê≠åÁæÖË•øÊõ∏',
  'Â∏ñÊííÁΩóÂ∞ºËø¶Ââç‰π¶', 'Â∏ñÊííÁæÖÂ∞ºËø¶ÂâçÊõ∏',
  'Â∏ñÊííÁΩóÂ∞ºËø¶Âêé‰π¶', 'Â∏ñÊííÁæÖÂ∞ºËø¶ÂæåÊõ∏',
  'ÊèêÊë©Â§™Ââç‰π¶', 'ÊèêÊë©Â§™ÂâçÊõ∏',
  'ÊèêÊë©Â§™Âêé‰π¶', 'ÊèêÊë©Â§™ÂæåÊõ∏',
  'ÊèêÂ§ö‰π¶', 'ÊèêÂ§öÊõ∏',
  'ËÖìÂà©Èó®‰π¶', 'ËÖìÂà©ÈñÄÊõ∏',
  'Â∏å‰ºØÊù•‰π¶', 'Â∏å‰ºØ‰æÜÊõ∏',
  'ÈõÖÂêÑ‰π¶', 'ÈõÖÂêÑÊõ∏',
  'ÂΩºÂæóÂâç‰π¶', 'ÂΩºÂæóÂâçÊõ∏',
  'ÂΩºÂæóÂêé‰π¶', 'ÂΩºÂæóÂæåÊõ∏',
  'Á∫¶Áø∞‰∏Ä‰π¶', 'Á¥ÑÁø∞‰∏ÄÊõ∏',
  'Á∫¶Áø∞‰∫å‰π¶', 'Á¥ÑÁø∞‰∫åÊõ∏',
  'Á∫¶Áø∞‰∏â‰π¶', 'Á¥ÑÁø∞‰∏âÊõ∏',
  'ÁäπÂ§ß‰π¶', 'Áå∂Â§ßÊõ∏',
  'ÂêØÁ§∫ÂΩï', 'ÂïüÁ§∫ÈåÑ',
};


================================================================================
FILE: constants/ui_strings.dart
================================================================================
const uiStrings = {
  // ====== Search Page ======
  'search': {
    'zh-Hans': 'ÊêúÁ¥¢',
    'zh-Hant': 'ÊêúÂ∞ã',
    'en': 'Search',
  },
  'searchResultCount': {
    'zh-Hans': 'ÂÖ± {count} Â§ÑÔºåÊåâ‰π¶ÁªüËÆ°Ôºö',
    'zh-Hant': 'ÂÖ± {count} ËôïÔºåÊåâÊõ∏Áµ±Ë®àÔºö',
    'en': 'Total {count} matches, grouped by book:',
  },
  'viewMoreBooksHint': {
    'zh-Hans': 'ÁÇπÂáªÊü•ÁúãÊõ¥Â§ö‰π¶Âç∑ÔºåÂè≥‰∏äËßíÁ≠õÈÄâÂèØË∑≥ËΩ¨Âà∞‰π¶Âç∑„ÄÇ',
    'zh-Hant': 'ÈªûÊìäÊü•ÁúãÊõ¥Â§öÊõ∏Âç∑ÔºåÂè≥‰∏äËßíÁØ©ÈÅ∏ÂèØË∑≥ËΩâÂà∞Êõ∏Âç∑„ÄÇ',
    'en': 'Tap to view more books; use top-right filter to jump to a book.',
  },
  'noResults': {
    'zh-Hans': 'Êú™ÊâæÂà∞ÁªìÊûú',
    'zh-Hant': 'Êâæ‰∏çÂà∞ÁµêÊûú',
    'en': 'No results found',
  },

  // ====== Search Filters ======
  'searchCurrentBook': {
    'zh-Hans': 'ÊêúÁ¥¢ÂΩìÂâç‰π¶Âç∑',
    'zh-Hant': 'ÊêúÂ∞ãÁï∂ÂâçÊõ∏Âç∑',
    'en': 'Search Current Book',
  },
  'searchEntireBible': {
    'zh-Hans': 'ÊêúÁ¥¢Êï¥Êú¨Âú£Áªè',
    'zh-Hant': 'ÊêúÂ∞ãÊï¥Êú¨ËÅñÁ∂ì',
    'en': 'Search Entire Bible',
  },

  // ====== General Navigation ======
  'back': {
    'zh-Hans': 'ËøîÂõû',
    'zh-Hant': 'ËøîÂõû',
    'en': 'Back',
  },
  'showMenu': {
    'zh-Hans': 'ÊòæÁ§∫ËèúÂçï',
    'zh-Hant': 'È°ØÁ§∫ÈÅ∏ÂñÆ',
    'en': 'Show menu',
  },

  // ====== Bible Navigation ======
  'oldTestament': {
    'zh-Hans': 'ÊóßÁ∫¶',
    'zh-Hant': 'ËàäÁ¥Ñ',
    'en': 'Old Testament',
  },
  'newTestament': {
    'zh-Hans': 'Êñ∞Á∫¶',
    'zh-Hant': 'Êñ∞Á¥Ñ',
    'en': 'New Testament',
  },
  'previousChapter': {
    'zh-Hans': '‰∏ä‰∏ÄÁ´†',
    'zh-Hant': '‰∏ä‰∏ÄÁ´†',
    'en': 'Previous Chapter',
  },
  'nextChapter': {
    'zh-Hans': '‰∏ã‰∏ÄÁ´†',
    'zh-Hant': '‰∏ã‰∏ÄÁ´†',
    'en': 'Next Chapter',
  },
  'bibleBooks': {
    'zh-Hans': '‰π¶Âç∑',
    'zh-Hant': 'Êõ∏Âç∑',
    'en': 'Bible Books',
  },
  'changeVersion': {
    'zh-Hans': 'ÂàáÊç¢ÁâàÊú¨',
    'zh-Hant': 'ÂàáÊèõÁâàÊú¨',
    'en': 'Change Version',
  },

  // ====== Settings Page ======
  'themeMode': {
    'zh-Hans': '‰∏ªÈ¢òÊ®°Âºè',
    'zh-Hant': '‰∏ªÈ°åÊ®°Âºè',
    'en': 'Theme Mode',
  },
  'themeDay': {
    'zh-Hans': 'ÁôΩÂ§©Ê®°Âºè',
    'zh-Hant': 'ÁôΩÂ§©Ê®°Âºè',
    'en': 'Light Mode',
  },
  'themeNight': {
    'zh-Hans': 'Â§úÈó¥Ê®°Âºè',
    'zh-Hant': 'Â§úÈñìÊ®°Âºè',
    'en': 'Dark Mode',
  },
  'themeSystem': {
    'zh-Hans': 'Ë∑üÈöèÁ≥ªÁªü',
    'zh-Hant': 'Ë∑üÈö®Á≥ªÁµ±',
    'en': 'System Default',
  },
  'themeLight': {
    'zh-Hans': '‰∫ÆËâ≤Ê®°Âºè',
    'zh-Hant': '‰∫ÆËâ≤Ê®°Âºè',
    'en': 'Light Mode',
  },
  'themeDark': {
    'zh-Hans': 'ÊöóËâ≤Ê®°Âºè',
    'zh-Hant': 'ÊöóËâ≤Ê®°Âºè',
    'en': 'Dark Mode',
  },
  'settings': {
    'zh-Hans': 'ËÆæÁΩÆ',
    'zh-Hant': 'Ë®≠ÂÆö',
    'en': 'Settings',
  },
  'allowUpdates': {
    'zh-Hans': 'ÂÖÅËÆ∏Ëá™Âä®Êõ¥Êñ∞',
    'zh-Hant': 'ÂÖÅË®±Ëá™ÂãïÊõ¥Êñ∞',
    'en': 'Allow Auto Updates',
  },
  'allowUpdatesSubtitle': {
    'zh-Hans': 'ÂàáÊç¢ÊòØÂê¶ÂÖÅËÆ∏‰ªéÊúçÂä°Âô®Êõ¥Êñ∞Â∫îÁî®Á®ãÂ∫è„ÄÇ',
    'zh-Hant': 'ÂàáÊèõÊòØÂê¶ÂÖÅË®±Âæû‰º∫ÊúçÂô®Êõ¥Êñ∞ÊáâÁî®Á®ãÂºè„ÄÇ',
    'en': 'Toggle whether to allow app updates from server.',
  },
  'interfaceLanguage': {
    'zh-Hans': 'ÁïåÈù¢ËØ≠Ë®Ä',
    'zh-Hant': '‰ªãÈù¢Ë™ûË®Ä',
    'en': 'Interface Language',
  },
  'fontSize': {
    'zh-Hans': 'Â≠ó‰ΩìÂ§ßÂ∞è',
    'zh-Hant': 'Â≠óÈ´îÂ§ßÂ∞è',
    'en': 'Font Size',
  },
  'lineSpacing': {
    'zh-Hans': 'Ë°åË∑ù',
    'zh-Hant': 'Ë°åË∑ù',
    'en': 'Line Spacing',
  },
  'fontFamily': {
    'zh-Hans': 'Â≠ó‰Ωì',
    'zh-Hant': 'Â≠óÈ´î',
    'en': 'Font Family',
  },
  'primaryColor': {
    'zh-Hans': '‰∏ªËâ≤Ë∞É',
    'zh-Hant': '‰∏ªËâ≤Ë™ø',
    'en': 'Primary Colour',
  },
  'samplePreview': {
    'zh-Hans': 'È¢ÑËßàÁ§∫ËåÉ',
    'zh-Hant': 'È†êË¶ΩÁ§∫ÁØÑ',
    'en': 'Sample Preview',
  },
  'copyFormat': {
    'zh-Hans': 'Â§çÂà∂Ê†ºÂºè',
    'zh-Hant': 'Ë§áË£ΩÊ†ºÂºè',
    'en': 'Copy Format',
  },
  'plainText': {
    'zh-Hans': 'Á∫ØÊñáÂ≠ó',
    'zh-Hant': 'Á¥îÊñáÂ≠ó',
    'en': 'Plain Text',
  },
  'withReference': {
    'zh-Hans': 'ÂåÖÂê´ÁªèÊñáÂèÇËÄÉ',
    'zh-Hant': 'ÂåÖÂê´Á∂ìÊñáÂèÉËÄÉ',
    'en': 'Include Reference',
  },
  'devotionalFormat': {
    'zh-Hans': 'ÁÅµ‰øÆÊ†ºÂºè',
    'zh-Hant': 'Èùà‰øÆÊ†ºÂºè',
    'en': 'Devotional Format',
  },
  'copyPreview': {
    'zh-Hans': 'Â§çÂà∂È¢ÑËßà',
    'zh-Hant': 'Ë§áË£ΩÈ†êË¶Ω',
    'en': 'Copy Preview',
  },
  'copied': {
    'zh-Hans': 'Â∑≤Â§çÂà∂ÔºÅ',
    'zh-Hant': 'Â∑≤Ë§áË£ΩÔºÅ',
    'en': 'Copied!',
  },
  'sendFeedback': {
    'zh-Hans': 'ÂèëÈÄÅÂèçÈ¶à',
    'zh-Hant': 'ÁôºÈÄÅÂèçÈ•ã',
    'en': 'Send Feedback',
  },
  'feedbackHint': {
    'zh-Hans': 'ËØ∑ËæìÂÖ•ÊÇ®ÁöÑÊÑèËßÅÊàñÂª∫ËÆÆÔºàÊúÄÂ§ö500Â≠óÔºâ...',
    'zh-Hant': 'Ë´ãËº∏ÂÖ•ÊÇ®ÁöÑÊÑèË¶ãÊàñÂª∫Ë≠∞ÔºàÊúÄÂ§ö500Â≠óÔºâ...',
    'en': 'Please enter your feedback (up to 500 characters)...',
  },
  'feedbackSuccess': {
    'zh-Hans': '‚úÖ Â∑≤ÊàêÂäüÂèëÈÄÅÔºåË∞¢Ë∞¢ÂèçÈ¶àÔºÅ',
    'zh-Hant': '‚úÖ ÁôºÈÄÅÊàêÂäüÔºåÊÑüË¨ùÊÇ®ÁöÑÂèçÈ•ãÔºÅ',
    'en': '‚úÖ Feedback sent. Thank you!',
  },
  'feedbackFailure': {
    'zh-Hans': '‚ùå ÂèëÈÄÅÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ',
    'zh-Hant': '‚ùå ÁôºÈÄÅÂ§±ÊïóÔºåË´ãÁ®çÂæåÈáçË©¶„ÄÇ',
    'en': '‚ùå Failed to send. Please try again.',
  },
  'ok': {
    'zh-Hans': 'Á°ÆÂÆö',
    'zh-Hant': 'Á¢∫ÂÆö',
    'en': 'OK',
  },

  'feedbackEmpty': {
    'zh-Hans': '‚ùóÔ∏èÂèëÈÄÅÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫ÔºåËØ∑ËæìÂÖ•ÂèçÈ¶àÂÜÖÂÆπ„ÄÇ',
    'zh-Hant': '‚ùóÔ∏èÁôºÈÄÅÂÖßÂÆπ‰∏çËÉΩÁÇ∫Á©∫ÔºåË´ãËº∏ÂÖ•ÂèçÈ•ãÂÖßÂÆπ„ÄÇ',
    'en': '‚ùóÔ∏èFeedback content cannot be empty. Please enter your feedback.',
  },
  'feedbackTooLong': {
    'zh-Hans': '‚ùóÔ∏èÂÜÖÂÆπË∂ÖËøáÊúÄÂ§ßÈïøÂ∫¶Ôºà500Â≠óÔºâÔºåËØ∑Âà†ÂáèÂêéÂÜçÂèëÈÄÅ„ÄÇ',
    'zh-Hant': '‚ùóÔ∏èÂÖßÂÆπË∂ÖÈÅéÊúÄÂ§ßÈï∑Â∫¶Ôºà500Â≠óÔºâÔºåË´ãÂà™Ê∏õÂæåÂÜçÁôºÈÄÅ„ÄÇ',
    'en':
        '‚ùóÔ∏èContent exceeds the maximum length (500 characters). Please shorten it before sending.',
  },
  'feedbackInvalid': {
    'zh-Hans': '‚ùóÔ∏èÂÜÖÂÆπÂåÖÂê´‰∏çÊîØÊåÅÁöÑÁ¨¶Âè∑ÔºàÂ¶ÇË°®ÊÉÖÁ¨¶Âè∑ÔºâÔºåËØ∑ÁßªÈô§ÂêéÂÜçÂèëÈÄÅ„ÄÇ',
    'zh-Hant': '‚ùóÔ∏èÂÖßÂÆπÂåÖÂê´‰∏çÊîØÊè¥ÁöÑÁ¨¶ËôüÔºàÂ¶ÇË°®ÊÉÖÁ¨¶ËôüÔºâÔºåË´ãÁßªÈô§ÂæåÂÜçÁôºÈÄÅ„ÄÇ',
    'en':
        '‚ùóÔ∏èContent contains unsupported symbols (such as emojis). Please remove them before sending.',
  },
};


================================================================================
FILE: constants/book_name_mapping.dart
================================================================================
const englishToChinese = {
  // Old Testament (Simplified)
  "Genesis": "Âàõ‰∏ñËÆ∞",
  "Exodus": "Âá∫ÂüÉÂèäËÆ∞",
  "Leviticus": "Âà©Êú™ËÆ∞",
  "Numbers": "Ê∞ëÊï∞ËÆ∞",
  "Deuteronomy": "Áî≥ÂëΩËÆ∞",
  "Joshua": "Á∫¶‰π¶‰∫öËÆ∞",
  "Judges": "Â£´Â∏àËÆ∞",
  "Ruth": "Ë∑ØÂæóËÆ∞",
  "1 Samuel": "ÊííÊØçËÄ≥ËÆ∞‰∏ä",
  "2 Samuel": "ÊííÊØçËÄ≥ËÆ∞‰∏ã",
  "1 Kings": "ÂàóÁéãÁ∫™‰∏ä",
  "2 Kings": "ÂàóÁéãÁ∫™‰∏ã",
  "1 Chronicles": "ÂéÜ‰ª£Âøó‰∏ä",
  "2 Chronicles": "ÂéÜ‰ª£Âøó‰∏ã",
  "Ezra": "‰ª•ÊñØÊãâËÆ∞",
  "Nehemiah": "Â∞ºÂ∏åÁ±≥ËÆ∞",
  "Esther": "‰ª•ÊñØÂ∏ñËÆ∞",
  "Job": "Á∫¶‰ºØËÆ∞",
  "Psalms": "ËØóÁØá",
  "Proverbs": "ÁÆ¥Ë®Ä",
  "Ecclesiastes": "‰º†ÈÅì‰π¶",
  "Song of Solomon": "ÈõÖÊ≠å",
  "Isaiah": "‰ª•Ëµõ‰∫ö‰π¶",
  "Jeremiah": "ËÄ∂Âà©Á±≥‰π¶",
  "Lamentations": "ËÄ∂Âà©Á±≥ÂìÄÊ≠å",
  "Ezekiel": "‰ª•Ë•øÁªì‰π¶",
  "Daniel": "‰ΩÜ‰ª•ÁêÜ‰π¶",
  "Hosea": "‰ΩïË•øÈòø‰π¶",
  "Joel": "Á∫¶Áè•‰π¶",
  "Amos": "ÈòøÊë©Âè∏‰π¶",
  "Obadiah": "‰øÑÂ∑¥Â∫ï‰∫ö‰π¶",
  "Jonah": "Á∫¶Êãø‰π¶",
  "Micah": "Âº•Ëø¶‰π¶",
  "Nahum": "ÈÇ£È∏ø‰π¶",
  "Habakkuk": "ÂìàÂ∑¥Ë∞∑‰π¶",
  "Zephaniah": "Ë•øÁï™ÈõÖ‰π¶",
  "Haggai": "ÂìàËØ•‰π¶",
  "Zechariah": "ÊííËø¶Âà©‰∫ö‰π¶",
  "Malachi": "ÁéõÊãâÂü∫‰π¶",

  // New Testament (Simplified)
  "Matthew": "È©¨Â§™Á¶èÈü≥",
  "Mark": "È©¨ÂèØÁ¶èÈü≥",
  "Luke": "Ë∑ØÂä†Á¶èÈü≥",
  "John": "Á∫¶Áø∞Á¶èÈü≥",
  "Acts": "‰ΩøÂæíË°å‰º†",
  "Romans": "ÁΩóÈ©¨‰π¶",
  "1 Corinthians": "Âì•ÊûóÂ§öÂâç‰π¶",
  "2 Corinthians": "Âì•ÊûóÂ§öÂêé‰π¶",
  "Galatians": "Âä†ÊãâÂ§™‰π¶",
  "Ephesians": "‰ª•ÂºóÊâÄ‰π¶",
  "Philippians": "ËÖìÁ´ãÊØî‰π¶",
  "Colossians": "Ê≠åÁΩóË•ø‰π¶",
  "1 Thessalonians": "Â∏ñÊííÁΩóÂ∞ºËø¶Ââç‰π¶",
  "2 Thessalonians": "Â∏ñÊííÁΩóÂ∞ºËø¶Âêé‰π¶",
  "1 Timothy": "ÊèêÊë©Â§™Ââç‰π¶",
  "2 Timothy": "ÊèêÊë©Â§™Âêé‰π¶",
  "Titus": "ÊèêÂ§ö‰π¶",
  "Philemon": "ËÖìÂà©Èó®‰π¶",
  "Hebrews": "Â∏å‰ºØÊù•‰π¶",
  "James": "ÈõÖÂêÑ‰π¶",
  "1 Peter": "ÂΩºÂæóÂâç‰π¶",
  "2 Peter": "ÂΩºÂæóÂêé‰π¶",
  "1 John": "Á∫¶Áø∞‰∏Ä‰π¶",
  "2 John": "Á∫¶Áø∞‰∫å‰π¶",
  "3 John": "Á∫¶Áø∞‰∏â‰π¶",
  "Jude": "ÁäπÂ§ß‰π¶",
  "Revelation": "ÂêØÁ§∫ÂΩï",
};

const englishToChineseTraditional = {
  // Old Testament
  "Genesis": "Ââµ‰∏ñÁ¥Ä",
  "Exodus": "Âá∫ÂüÉÂèäË®ò",
  "Leviticus": "Âà©Êú™Ë®ò",
  "Numbers": "Ê∞ëÊï∏Ë®ò",
  "Deuteronomy": "Áî≥ÂëΩË®ò",
  "Joshua": "Á¥ÑÊõ∏‰∫ûË®ò",
  "Judges": "Â£´Â∏´Ë®ò",
  "Ruth": "Ë∑ØÂæóË®ò",
  "1 Samuel": "ÊííÊØçËÄ≥Ë®ò‰∏ä",
  "2 Samuel": "ÊííÊØçËÄ≥Ë®ò‰∏ã",
  "1 Kings": "ÂàóÁéãÁ¥Ä‰∏ä",
  "2 Kings": "ÂàóÁéãÁ¥Ä‰∏ã",
  "1 Chronicles": "Ê≠∑‰ª£Âøó‰∏ä",
  "2 Chronicles": "Ê≠∑‰ª£Âøó‰∏ã",
  "Ezra": "‰ª•ÊñØÊãâË®ò",
  "Nehemiah": "Â∞ºÂ∏åÁ±≥Ë®ò",
  "Esther": "‰ª•ÊñØÂ∏ñË®ò",
  "Job": "Á¥Ñ‰ºØË®ò",
  "Psalms": "Ë©©ÁØá",
  "Proverbs": "ÁÆ¥Ë®Ä",
  "Ecclesiastes": "ÂÇ≥ÈÅìÊõ∏",
  "Song of Solomon": "ÈõÖÊ≠å",
  "Isaiah": "‰ª•Ë≥Ω‰∫ûÊõ∏",
  "Jeremiah": "ËÄ∂Âà©Á±≥Êõ∏",
  "Lamentations": "ËÄ∂Âà©Á±≥ÂìÄÊ≠å",
  "Ezekiel": "‰ª•Ë•øÁµêÊõ∏",
  "Daniel": "‰ΩÜ‰ª•ÁêÜÊõ∏",
  "Hosea": "‰ΩïË•øÈòøÊõ∏",
  "Joel": "Á¥ÑÁè•Êõ∏",
  "Amos": "ÈòøÊë©Âè∏Êõ∏",
  "Obadiah": "‰øÑÂ∑¥Â∫ï‰∫ûÊõ∏",
  "Jonah": "Á¥ÑÊãøÊõ∏",
  "Micah": "ÂΩåËø¶Êõ∏",
  "Nahum": "ÈÇ£È¥ªÊõ∏",
  "Habakkuk": "ÂìàÂ∑¥Ë∞∑Êõ∏",
  "Zephaniah": "Ë•øÁï™ÈõÖÊõ∏",
  "Haggai": "ÂìàË©≤Êõ∏",
  "Zechariah": "ÊííËø¶Âà©‰∫ûÊõ∏",
  "Malachi": "Áë™ÊãâÂü∫Êõ∏",

  // New Testament
  "Matthew": "È¶¨Â§™Á¶èÈü≥",
  "Mark": "È¶¨ÂèØÁ¶èÈü≥",
  "Luke": "Ë∑ØÂä†Á¶èÈü≥",
  "John": "Á¥ÑÁø∞Á¶èÈü≥",
  "Acts": "‰ΩøÂæíË°åÂÇ≥",
  "Romans": "ÁæÖÈ¶¨Êõ∏",
  "1 Corinthians": "Âì•ÊûóÂ§öÂâçÊõ∏",
  "2 Corinthians": "Âì•ÊûóÂ§öÂæåÊõ∏",
  "Galatians": "Âä†ÊãâÂ§™Êõ∏",
  "Ephesians": "‰ª•ÂºóÊâÄÊõ∏",
  "Philippians": "ËÖìÁ´ãÊØîÊõ∏",
  "Colossians": "Ê≠åÁæÖË•øÊõ∏",
  "1 Thessalonians": "Â∏ñÊííÁæÖÂ∞ºËø¶ÂâçÊõ∏",
  "2 Thessalonians": "Â∏ñÊííÁæÖÂ∞ºËø¶ÂæåÊõ∏",
  "1 Timothy": "ÊèêÊë©Â§™ÂâçÊõ∏",
  "2 Timothy": "ÊèêÊë©Â§™ÂæåÊõ∏",
  "Titus": "ÊèêÂ§öÊõ∏",
  "Philemon": "ËÖìÂà©ÈñÄÊõ∏",
  "Hebrews": "Â∏å‰ºØ‰æÜÊõ∏",
  "James": "ÈõÖÂêÑÊõ∏",
  "1 Peter": "ÂΩºÂæóÂâçÊõ∏",
  "2 Peter": "ÂΩºÂæóÂæåÊõ∏",
  "1 John": "Á¥ÑÁø∞‰∏ÄÊõ∏",
  "2 John": "Á¥ÑÁø∞‰∫åÊõ∏",
  "3 John": "Á¥ÑÁø∞‰∏âÊõ∏",
  "Jude": "Áå∂Â§ßÊõ∏",
  "Revelation": "ÂïüÁ§∫ÈåÑ",
};

// Â∏∏ËßÅÁöÑ‰∏≠ÊñáÂà´ÂÜôÔºàÁÆÄ/ÁπÅ / ÂºÇ‰ΩìÂ≠óÔºâ‚Üí Ëã±ÊñáÈîÆÔºåÁî®‰∫éÂÆπÈîô
// Â∏∏ËßÅÁöÑ‰∏≠ÊñáÂà´ÂÜôÔºàÁÆÄ / ÁπÅ / ÂºÇ‰ΩìÂ≠ó / ÊóßËØëÂêçÔºâ‚Üí Ëã±ÊñáÈîÆ
const _zhAliasToEn = {
  // ===== Old Testament =====
  'Âàõ‰∏ñÁ∫™': 'Genesis', 'Ââµ‰∏ñÁ¥Ä': 'Genesis', 'Âàõ‰∏ñËÆ∞': 'Genesis', 'Ââµ‰∏ñË®ò': 'Genesis',
  'Âá∫ÂüÉÂèäËÆ∞': 'Exodus', 'Âá∫ÂüÉÂèäË®ò': 'Exodus',
  'Âà©Êú™ËÆ∞': 'Leviticus', 'Âà©Êú™Ë®ò': 'Leviticus',
  'Ê∞ëÊï∞ËÆ∞': 'Numbers', 'Ê∞ëÊï∏Ë®ò': 'Numbers',
  'Áî≥ÂëΩËÆ∞': 'Deuteronomy', 'Áî≥ÂëΩË®ò': 'Deuteronomy',
  'Á∫¶‰π¶‰∫öËÆ∞': 'Joshua', 'Á¥ÑÊõ∏‰∫ûË®ò': 'Joshua',
  'Â£´Â∏àËÆ∞': 'Judges', 'Â£´Â∏´Ë®ò': 'Judges',
  'Ë∑ØÂæóËÆ∞': 'Ruth', 'Ë∑ØÂæóË®ò': 'Ruth',
  'ÊííÊØçËÄ≥ËÆ∞‰∏ä': '1 Samuel', 'ÊííÊØçËÄ≥Ë®ò‰∏ä': '1 Samuel',
  'ÊííÊØçËÄ≥ËÆ∞‰∏ã': '2 Samuel', 'ÊííÊØçËÄ≥Ë®ò‰∏ã': '2 Samuel',
  'ÂàóÁéãÁ∫™‰∏ä': '1 Kings', 'ÂàóÁéãÁ¥Ä‰∏ä': '1 Kings',
  'ÂàóÁéãÁ∫™‰∏ã': '2 Kings', 'ÂàóÁéãÁ¥Ä‰∏ã': '2 Kings',
  'ÂéÜ‰ª£Âøó‰∏ä': '1 Chronicles', 'Ê≠∑‰ª£Âøó‰∏ä': '1 Chronicles',
  'ÂéÜ‰ª£Âøó‰∏ã': '2 Chronicles', 'Ê≠∑‰ª£Âøó‰∏ã': '2 Chronicles',
  '‰ª•ÊñØÊãâËÆ∞': 'Ezra', '‰ª•ÊñØÊãâË®ò': 'Ezra',
  'Â∞ºÂ∏åÁ±≥ËÆ∞': 'Nehemiah', 'Â∞ºÂ∏åÁ±≥Ë®ò': 'Nehemiah',
  '‰ª•ÊñØÂ∏ñËÆ∞': 'Esther', '‰ª•ÊñØÂ∏ñË®ò': 'Esther',
  'Á∫¶‰ºØËÆ∞': 'Job', 'Á¥Ñ‰ºØË®ò': 'Job',
  'ËØóÁØá': 'Psalms', 'Ë©©ÁØá': 'Psalms',
  'ÁÆ¥Ë®Ä': 'Proverbs',
  '‰º†ÈÅì‰π¶': 'Ecclesiastes', 'ÂÇ≥ÈÅìÊõ∏': 'Ecclesiastes',
  'ÈõÖÊ≠å': 'Song of Solomon',
  '‰ª•Ëµõ‰∫ö‰π¶': 'Isaiah', '‰ª•Ë≥Ω‰∫ûÊõ∏': 'Isaiah',
  'ËÄ∂Âà©Á±≥‰π¶': 'Jeremiah', 'ËÄ∂Âà©Á±≥Êõ∏': 'Jeremiah',
  'ËÄ∂Âà©Á±≥ÂìÄÊ≠å': 'Lamentations',
  '‰ª•Ë•øÁªì‰π¶': 'Ezekiel', '‰ª•Ë•øÁµêÊõ∏': 'Ezekiel',
  '‰ΩÜ‰ª•ÁêÜ‰π¶': 'Daniel', '‰ΩÜ‰ª•ÁêÜÊõ∏': 'Daniel',
  '‰ΩïË•øÈòø‰π¶': 'Hosea', '‰ΩïË•øÈòøÊõ∏': 'Hosea',
  'Á∫¶Áè•‰π¶': 'Joel', 'Á¥ÑÁè•Êõ∏': 'Joel',
  'ÈòøÊë©Âè∏‰π¶': 'Amos', 'ÈòøÊë©Âè∏Êõ∏': 'Amos',
  '‰øÑÂ∑¥Â∫ï‰∫ö‰π¶': 'Obadiah', '‰øÑÂ∑¥Â∫ï‰∫ûÊõ∏': 'Obadiah',
  'Á∫¶Êãø‰π¶': 'Jonah', 'Á¥ÑÊãøÊõ∏': 'Jonah',
  'Âº•Ëø¶‰π¶': 'Micah', 'ÂΩåËø¶Êõ∏': 'Micah',
  'ÈÇ£È∏ø‰π¶': 'Nahum', 'ÈÇ£È¥ªÊõ∏': 'Nahum',
  'ÂìàÂ∑¥Ë∞∑‰π¶': 'Habakkuk', 'ÂìàÂ∑¥Ë∞∑Êõ∏': 'Habakkuk',
  'Ë•øÁï™ÈõÖ‰π¶': 'Zephaniah', 'Ë•øÁï™ÈõÖÊõ∏': 'Zephaniah',
  'ÂìàËØ•‰π¶': 'Haggai', 'ÂìàË©≤Êõ∏': 'Haggai',
  'ÊííËø¶Âà©‰∫ö‰π¶': 'Zechariah', 'ÊííËø¶Âà©‰∫ûÊõ∏': 'Zechariah',
  'ÁéõÊãâÂü∫‰π¶': 'Malachi', 'Áë™ÊãâÂü∫Êõ∏': 'Malachi',

  // ===== New Testament =====
  'È©¨Â§™Á¶èÈü≥': 'Matthew', 'È¶¨Â§™Á¶èÈü≥': 'Matthew',
  'È©¨ÂèØÁ¶èÈü≥': 'Mark', 'È¶¨ÂèØÁ¶èÈü≥': 'Mark',
  'Ë∑ØÂä†Á¶èÈü≥': 'Luke',
  'Á∫¶Áø∞Á¶èÈü≥': 'John', 'Á¥ÑÁø∞Á¶èÈü≥': 'John',
  '‰ΩøÂæíË°å‰º†': 'Acts', '‰ΩøÂæíË°åÂÇ≥': 'Acts',
  'ÁΩóÈ©¨‰π¶': 'Romans', 'ÁæÖÈ¶¨Êõ∏': 'Romans',
  'Âì•ÊûóÂ§öÂâç‰π¶': '1 Corinthians', 'Âì•ÊûóÂ§öÂâçÊõ∏': '1 Corinthians',
  'Âì•ÊûóÂ§öÂêé‰π¶': '2 Corinthians', 'Âì•ÊûóÂ§öÂæåÊõ∏': '2 Corinthians',
  'Âä†ÊãâÂ§™‰π¶': 'Galatians', 'Âä†ÊãâÂ§™Êõ∏': 'Galatians',
  '‰ª•ÂºóÊâÄ‰π¶': 'Ephesians', '‰ª•ÂºóÊâÄÊõ∏': 'Ephesians',
  'ËÖìÁ´ãÊØî‰π¶': 'Philippians', 'ËÖìÁ´ãÊØîÊõ∏': 'Philippians',
  'Ê≠åÁΩóË•ø‰π¶': 'Colossians', 'Ê≠åÁæÖË•øÊõ∏': 'Colossians',
  'Â∏ñÊííÁΩóÂ∞ºËø¶Ââç‰π¶': '1 Thessalonians', 'Â∏ñÊííÁæÖÂ∞ºËø¶ÂâçÊõ∏': '1 Thessalonians',
  'Â∏ñÊííÁΩóÂ∞ºËø¶Âêé‰π¶': '2 Thessalonians', 'Â∏ñÊííÁæÖÂ∞ºËø¶ÂæåÊõ∏': '2 Thessalonians',
  'ÊèêÊë©Â§™Ââç‰π¶': '1 Timothy', 'ÊèêÊë©Â§™ÂâçÊõ∏': '1 Timothy',
  'ÊèêÊë©Â§™Âêé‰π¶': '2 Timothy', 'ÊèêÊë©Â§™ÂæåÊõ∏': '2 Timothy',
  'ÊèêÂ§ö‰π¶': 'Titus', 'ÊèêÂ§öÊõ∏': 'Titus',
  'ËÖìÂà©Èó®‰π¶': 'Philemon', 'ËÖìÂà©ÈñÄÊõ∏': 'Philemon',
  'Â∏å‰ºØÊù•‰π¶': 'Hebrews', 'Â∏å‰ºØ‰æÜÊõ∏': 'Hebrews',
  'ÈõÖÂêÑ‰π¶': 'James', 'ÈõÖÂêÑÊõ∏': 'James',
  'ÂΩºÂæóÂâç‰π¶': '1 Peter', 'ÂΩºÂæóÂâçÊõ∏': '1 Peter',
  'ÂΩºÂæóÂêé‰π¶': '2 Peter', 'ÂΩºÂæóÂæåÊõ∏': '2 Peter',
  'Á∫¶Áø∞‰∏Ä‰π¶': '1 John', 'Á¥ÑÁø∞‰∏ÄÊõ∏': '1 John',
  'Á∫¶Áø∞‰∫å‰π¶': '2 John', 'Á¥ÑÁø∞‰∫åÊõ∏': '2 John',
  'Á∫¶Áø∞‰∏â‰π¶': '3 John', 'Á¥ÑÁø∞‰∏âÊõ∏': '3 John',
  'ÁäπÂ§ß‰π¶': 'Jude', 'Áå∂Â§ßÊõ∏': 'Jude',
  'ÂêØÁ§∫ÂΩï': 'Revelation', 'ÂïüÁ§∫ÈåÑ': 'Revelation',
};

/// Êää‰∏≠Êñá‰π¶ÂêçÔºàÁÆÄ‰ΩìÊàñÁπÅ‰ΩìÔºâËΩ¨Êç¢‰∏∫Ëã±ÊñáÈîÆÔºõËã•Êâæ‰∏çÂà∞ÂàôËøîÂõû null
String? zhToEn(String name) {
  final hitHans = englishToChinese.entries
      .firstWhere((e) => e.value == name, orElse: () => const MapEntry('', ''));
  if (hitHans.key.isNotEmpty) return hitHans.key;

  final hitHant = englishToChineseTraditional.entries
      .firstWhere((e) => e.value == name, orElse: () => const MapEntry('', ''));
  if (hitHant.key.isNotEmpty) return hitHant.key;

  // Âà´ÂÜôÂÆπÈîô
  return _zhAliasToEn[name];
}

String toLocale(String englishKey, String version) {
  if (version == 'kjv' || version == 'leb') return englishKey;
  return version.endsWith('-tr')
      ? englishToChineseTraditional[englishKey] ?? englishKey
      : englishToChinese[englishKey] ?? englishKey;
}


================================================================================
FILE: providers/main_provider.dart
================================================================================
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:yswords/models/verse.dart';
import 'package:yswords/models/book.dart';
import 'package:scrollable_positioned_list/scrollable_positioned_list.dart';
import 'package:shared_preferences/shared_preferences.dart';

// MainProvider class to extends ChangeNotifier for state management

class MainProvider extends ChangeNotifier {
  // Index of a verse to temporarily highlight
  int? highlightIndex;

  /// Temporarily highlight the verse at [index]
  void setHighlightIndex(int index) {
    highlightIndex = index;
    notifyListeners();
  }

  /// Clear any temporary highlight
  void clearHighlightIndex() {
    highlightIndex = null;
    notifyListeners();
  }

  void setVerses(List<Verse> list) {
    verses = list;
    notifyListeners();
  }

  void setBooks(List<Book> list) {
    books = list;
    notifyListeners();
  }

  // Contollers and Listeners for managing scroll positions and items
  ItemScrollController itemScrollController = ItemScrollController();
  ScrollOffsetController scrollOffsetController = ScrollOffsetController();
  ItemPositionsListener itemPositionsListener = ItemPositionsListener.create();
  ScrollOffsetListener scrollOffsetListener = ScrollOffsetListener.create();

  // Variables to store the current chapter and book
  int? currentChapter;
  String? currentBook;
  String currentVersion = 'cuvs-yhwh'; // default version

  void setVersion(String version) {
    currentVersion = version;
    saveCurrentState();
    notifyListeners();
  }

  List<Verse> verses = [];
  // Set to store selected verse IDs
  final Set<String> _selectedIds = {};

  // List of Store Verse Objects
  List<Verse> get selectedVerses =>
      verses.where((v) => _selectedIds.contains(v.id)).toList();
  Set<String> get selectedIds => _selectedIds;

  bool isSelected(Verse v) => _selectedIds.contains(v.id);

  // Method to set the current book and chapter, persist state, and notify listeners
  void setCurrentChapter({required String book, required int chapter}) {
    currentBook = book;
    currentChapter = chapter;
    saveCurrentState();
    notifyListeners();
  }

  // Method to add a verse to the list and notify listeners
  void addVerse({required Verse verse}) {
    verses.add(verse);
    notifyListeners();
  }

  // List to store Book Objects
  List<Book> books = [];

  // Method to add a book to the list and notify listeners
  void addBook({required Book book}) {
    books.add(book);
    notifyListeners();
  }

  // Variable to store the current verse
  Verse? currentVerse;
  // Method to update the current verse and notify listeners
  void updateCurrentVerse({required Verse verse}) {
    currentVerse = verse;
    notifyListeners();
  }

  // Method to scroll to a specific index in the list and notify listeners
  void scrollToIndex({required int index}) {
    // debugPrint(
    //     'üåÄ scrollToIndex: index=$index, controller attached: ${itemScrollController.isAttached}');
    if (itemScrollController.isAttached) {
      itemScrollController.scrollTo(
        index: index,
        duration: const Duration(milliseconds: 800),
      );
    } else {
      // debugPrint('‚ö†Ô∏è scrollToIndex skipped: controller not attached');
    }
    notifyListeners();
  }

  void jumpToIndex({required int index}) {
    if (itemScrollController.isAttached) {
      itemScrollController.jumpTo(index: index);
    }
  }

  // Method to toggle the selection of a Verse and notify listeners
  void toggleVerse({required Verse verse}) {
    if (!_selectedIds.remove(verse.id)) {
      _selectedIds.add(verse.id);
    }
    // debugPrint('selected=${_selectedIds.length}');

    notifyListeners();
  }

  // Method to clear the selected verses and notify listeners
  void clearSelectedVerses() {
    _selectedIds.clear();
    notifyListeners();
  }
  Future<void> saveCurrentState() async {
    final prefs = await SharedPreferences.getInstance();
    if (currentBook != null) prefs.setString('book', currentBook!);
    if (currentChapter != null) prefs.setInt('chapter', currentChapter!);
    prefs.setString('version', currentVersion);
  }

  Future<void> restoreState() async {
    final prefs = await SharedPreferences.getInstance();
    final savedVersion = prefs.getString('version');
    final savedBook = prefs.getString('book');
    final savedChapter = prefs.getInt('chapter');

    if (savedVersion != null) currentVersion = savedVersion;
    if (savedBook != null) currentBook = savedBook;
    if (savedChapter != null) currentChapter = savedChapter;

    notifyListeners();
  }
}


================================================================================
FILE: utils/clipboard_helper.dart
================================================================================
import 'package:flutter/services.dart';

abstract class ClipboardHelper {
  static Future<void> copyText(String text) async {
    await Clipboard.setData(ClipboardData(text: text));
  }
}


================================================================================
FILE: utils/format_searched_text.dart
================================================================================
import 'package:flutter/material.dart';

Text formatSearchText({
  required String input,
  required String text,
  required BuildContext context,
}) {
  // Check if the input or text is empty
  if (input.isEmpty || text.isEmpty) {
    return Text(input);
  }

  // List to store formatted text spans
  List<TextSpan> textSpans = [];

  // Create a regular expression to find all matches of the search text
  RegExp regExp = RegExp(text, caseSensitive: false);

  // Find all matches in the input string
  Iterable<Match> matches = regExp.allMatches(input);

  // Initialize the current index to track the position in the input string
  int currentIndex = 0;

  // Loop through the matches
  for (Match match in matches) {
    // Add non-matching text span
    textSpans.add(TextSpan(text: input.substring(currentIndex, match.start)));

    // Add matching text span with styling
    textSpans.add(
      TextSpan(
        text: input.substring(match.start, match.end),
        style: TextStyle(
          color: Theme.of(context).colorScheme.primary,
          fontWeight: FontWeight.bold,
        ),
      ),
    );

    // Update the current index
    currentIndex = match.end;
  }

  // Add the remaining non-matching text span
  textSpans.add(TextSpan(text: input.substring(currentIndex)));

  // Return the formatted text with spans
  return Text.rich(TextSpan(children: textSpans));
}


================================================================================
FILE: utils/version_mapper.dart
================================================================================
import 'package:yswords/constants/book_name_mapping.dart' show zhToEn, toLocale;

String translateBookName(String? book, String version) {
  if (book == null) return '';
  final en = zhToEn(book) ?? book;
  return toLocale(en, version);
}

String? toEnglish(String? book) {
  if (book == null || book.isEmpty) return null;

  final mapped = zhToEn(book);
  if (mapped != null) return mapped;

  return book;
}


================================================================================
FILE: models/app_settings.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class AppSettings extends ChangeNotifier {
  String _fontFamily = 'Roboto';
  double _fontSize = 20.0;
  double _lineSpacing = 1.5;
  Color _primaryColor = Colors.lightBlue;
  String _copyFormat = 'withRef';
  bool _allowUpdates = true;
  bool _lockAllowUpdates = false;
  String _locale = 'zh-Hans';
  ThemeMode _themeMode = ThemeMode.system;
  bool _readingModeCentered = false;
  bool get readingModeCentered => _readingModeCentered;

  String get fontFamily => _fontFamily;
  double get fontSize => _fontSize;
  double get lineSpacing => _lineSpacing;
  Color get primaryColor => _primaryColor;
  String get copyFormat => _copyFormat;
  bool get allowUpdates => _allowUpdates;
  bool get lockAllowUpdates => _lockAllowUpdates;
  String get locale => _locale;
  ThemeMode get themeMode => _themeMode;

  void setFontFamily(String family) async {
    _fontFamily = family;
    final prefs = await SharedPreferences.getInstance();
    prefs.setString('fontFamily', family);
    notifyListeners();
  }

  void setFontSize(double size) async {
    _fontSize = size;
    final prefs = await SharedPreferences.getInstance();
    prefs.setDouble('fontSize', size);
    notifyListeners();
  }

  void setLineSpacing(double spacing) async {
    _lineSpacing = spacing;
    final prefs = await SharedPreferences.getInstance();
    prefs.setDouble('lineSpacing', spacing);
    notifyListeners();
  }

  void setPrimaryColor(Color color) async {
    _primaryColor = color;
    final prefs = await SharedPreferences.getInstance();
    prefs.setInt('primaryColor', color.value);
    notifyListeners();
  }

  void setCopyFormat(String format) async {
    _copyFormat = format;
    final prefs = await SharedPreferences.getInstance();
    prefs.setString('copyFormat', format);
    notifyListeners();
  }

  void setAllowUpdates(bool allow) async {
    _allowUpdates = allow;
    final prefs = await SharedPreferences.getInstance();
    prefs.setBool('allowUpdates', allow);
    notifyListeners();
  }

  void setLockAllowUpdates(bool lock) {
    _lockAllowUpdates = lock;
    notifyListeners();
  }

  void setLocale(String langCode) async {
    _locale = langCode;
    final prefs = await SharedPreferences.getInstance();
    prefs.setString('locale', langCode);
    notifyListeners();
  }

  void setThemeMode(ThemeMode mode) async {
    _themeMode = mode;
    final prefs = await SharedPreferences.getInstance();
    prefs.setString('themeMode', mode.toString());
    notifyListeners();
  }

  void setReadingModeCentered(bool centered) async {
    _readingModeCentered = centered;
    final prefs = await SharedPreferences.getInstance();
    prefs.setBool('readingModeCentered', centered);
    notifyListeners();
  }

  Future<void> loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    _fontFamily = prefs.getString('fontFamily') ?? 'Roboto';
    _fontSize = prefs.getDouble('fontSize') ?? 20.0;
    _lineSpacing = prefs.getDouble('lineSpacing') ?? 1.5;
    _primaryColor =
        Color(prefs.getInt('primaryColor') ?? Colors.lightBlue.value);
    _copyFormat = prefs.getString('copyFormat') ?? 'withRef';
    _allowUpdates = prefs.getBool('allowUpdates') ?? true;
    _lockAllowUpdates = false;
    _locale = prefs.getString('locale') ?? _detectSystemLocale();
    final themeModeString = prefs.getString('themeMode') ?? 'ThemeMode.system';
    switch (themeModeString) {
      case 'ThemeMode.light':
        _themeMode = ThemeMode.light;
        break;
      case 'ThemeMode.dark':
        _themeMode = ThemeMode.dark;
        break;
      default:
        _themeMode = ThemeMode.system;
    }
    _readingModeCentered = prefs.getBool('readingModeCentered') ?? false;
    notifyListeners();
  }

  String _detectSystemLocale() {
    final String systemLocale =
        WidgetsBinding.instance.platformDispatcher.locale.languageCode;
    if (systemLocale == 'zh') {
      final String? scriptCode =
          WidgetsBinding.instance.platformDispatcher.locale.scriptCode;
      if (scriptCode == 'Hant') {
        return 'zh-Hant';
      } else {
        return 'zh-Hans';
      }
    } else {
      return 'en';
    }
  }
}


================================================================================
FILE: models/verse.dart
================================================================================
import 'package:flutter/widgets.dart';

@immutable
class Verse {
  final String book;
  final int chapter;
  final int verse;
  final String text;
  final bool isParagraphStart;

  const Verse({
    required this.book,
    required this.chapter,
    required this.verse,
    required this.text,
    this.isParagraphStart = false,
  });

  String get id => '$book-$chapter-$verse';
  // Factory constructor to create a Verse object from a JSON map
  factory Verse.fromJson(Map<String, dynamic> json) {
    final chapterStr = json['chapter']?.toString() ?? '';
    final verseStr = json['verse']?.toString() ?? '';
    final chapterNum = int.tryParse(chapterStr);
    final verseNum = int.tryParse(verseStr);
    if (chapterNum == null || verseNum == null) {
      throw FormatException(
        'Skipping non-numeric entry: chapter="$chapterStr", verse="$verseStr"'
      );
    }
    return Verse(
      book: json['book'] as String,
      chapter: chapterNum,
      verse: verseNum,
      text: json['text'] as String,
      isParagraphStart: json['isParagraphStart'] as bool? ?? false,
    );
  }
}


================================================================================
FILE: models/book.dart
================================================================================
import 'chapter.dart';

class Book {
  final String title;
  final List<Chapter> chapters;

  Book({
    required this.title,
    required this.chapters,
  });
}


================================================================================
FILE: models/chapter.dart
================================================================================
import 'verse.dart';

class Chapter {
  final int title;
  final List<Verse> verses;

  Chapter({
    required this.title,
    required this.verses,
  });
}


================================================================================
FILE: pages/loading_page.dart
================================================================================
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/app_settings.dart';
import '../models/verse.dart';
import 'home_page.dart';

class LoadingPage extends StatefulWidget {
  final List<Verse> verses;
  const LoadingPage({super.key, required this.verses});

  @override
  State<LoadingPage> createState() => _LoadingPageState();
}

class _LoadingPageState extends State<LoadingPage> {
  @override
  void initState() {
    super.initState();
    Future.delayed(const Duration(seconds: 3), () {
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => const HomePage()),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final settings = Provider.of<AppSettings>(context, listen: false);
    // final today = DateTime.now();
    final verse =
        widget.verses.isNotEmpty ? (widget.verses..shuffle()).first : null;

    final notePattern   = RegExp(r'<note:[^>]*>');
    final bracePattern  = RegExp(r'\{[^}]*\}');
    final squarePattern = RegExp(r'\[([^\]]+)\]');
    // Combined to split text and bracket tokens
    final combinedPattern = RegExp(r'(\[[^\]]+\])');
    final original      = verse?.text.replaceAll('\n', '') ?? '';
    // Remove only notes and braces, keep square brackets for rendering
    final raw           = original.replaceAll(notePattern, '').replaceAll(bracePattern, '').trim();
    // Split so that each [word] is its own part
    final parts         = raw.splitMapJoin(
      combinedPattern,
      onMatch:    (m) => '||${m[0]}||',
      onNonMatch: (n) => n,
    ).split('||');

    return Scaffold(
      backgroundColor: Theme.of(context).colorScheme.background,
      body: Center(
        child: verse == null
            ? const Text('No verses available')
            : Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Image.asset(
                    'assets/loading.png',
                    width: 150,
                    height: 150,
                  ),
                  const SizedBox(height: 24),
                  const SizedBox(height: 16),
                  Column(
                    children: [
                      Text(
                        'YsWords',
                        style: TextStyle(
                          fontSize: settings.fontSize * 1.2,
                          fontFamily: settings.fontFamily,
                          color: Theme.of(context).colorScheme.primary,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      SizedBox(height: 4),
                      Text(
                        'ÈõÖ‰ºü‰πãË®Ä',
                        style: TextStyle(
                          fontSize: settings.fontSize * 1.0,
                          color: Theme.of(context).colorScheme.primary,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 48),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 32.0),
                    child: RichText(
                      textAlign: TextAlign.center,
                      text: TextSpan(
                        children: parts.map<InlineSpan>((part) {
                          final match = squarePattern.firstMatch(part);
                          if (match != null) {
                            return TextSpan(
                              text: match.group(1),
                              style: TextStyle(
                                fontSize: settings.fontSize,
                                fontFamily: settings.fontFamily,
                                height: 1.5,
                                decoration: TextDecoration.underline,
                                decorationStyle: TextDecorationStyle.dotted,
                                decorationColor: Theme.of(context).colorScheme.primary,
                                decorationThickness: 2.0,
                                color: Theme.of(context).textTheme.bodyLarge?.color,
                              ),
                            );
                          } else {
                            return TextSpan(
                              text: part,
                              style: TextStyle(
                                fontSize: settings.fontSize,
                                fontFamily: settings.fontFamily,
                                height: 1.5,
                                color: Theme.of(context).textTheme.bodyLarge?.color,
                              ),
                            );
                          }
                        }).toList(),
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    '${verse.book} ${verse.chapter}:${verse.verse}',
                    style: TextStyle(
                      fontSize: settings.fontSize * 0.9,
                      color: Theme.of(context)
                          .textTheme
                          .titleSmall
                          ?.color
                          ?.withOpacity(0.7),
                    ),
                  ),
                ],
              ),
      ),
    );
  }
}


================================================================================
FILE: pages/home_page.dart
================================================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:clipboard/clipboard.dart';

import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:provider/provider.dart';
import 'package:scrollable_positioned_list/scrollable_positioned_list.dart';

import 'package:yswords/models/verse.dart';
import 'package:yswords/models/app_settings.dart';
import 'package:yswords/pages/books_page.dart';
import 'package:yswords/pages/search_page.dart';
import 'package:yswords/pages/settings_page.dart';
import 'package:yswords/providers/main_provider.dart';
import 'package:yswords/services/fetch_books.dart';
import 'package:yswords/services/fetch_verses.dart';
import 'package:yswords/services/read_last_index.dart';
import 'package:yswords/utils/clipboard_helper.dart';
import 'package:yswords/widgets/verse_widget.dart';
import 'package:yswords/utils/version_mapper.dart'
    show translateBookName, toEnglish;
import 'package:yswords/constants/ui_strings.dart';

class CustomFloatingActionButtonLocation extends FloatingActionButtonLocation {
  final double xOffset;
  final double yOffset;

  const CustomFloatingActionButtonLocation({
    this.xOffset = 0.0,
    this.yOffset = 0.0,
  });

  @override
  Offset getOffset(ScaffoldPrelayoutGeometry scaffoldGeometry) {
    final endFloat =
        FloatingActionButtonLocation.endFloat.getOffset(scaffoldGeometry);
    return endFloat.translate(xOffset, yOffset);
  }
}

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  bool _controllerInitialized = false;
  final ScrollController _fakeScrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      final mainProvider = Provider.of<MainProvider>(context, listen: false);
      final settings = Provider.of<AppSettings>(context, listen: false);
      if (mainProvider.verses.isEmpty) {
        await FetchVerses.execute(
            mainProvider: mainProvider, settings: settings);
        await FetchBooks.execute(
            mainProvider: mainProvider, settings: settings);
      }
      await ReadLastIndex.execute().then((index) {
        if (index != null) {
          mainProvider.scrollToIndex(index: index);
        }
      });
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    if (!_controllerInitialized) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final provider = Provider.of<MainProvider>(context, listen: false);
        if (provider.books.isEmpty) return;

        setState(() {
          _controllerInitialized = true;
        });

        // ‚úÖ Moved here!
        provider.clearSelectedVerses();
      });
    } else {
      // ‚úÖ Clear outside build frame
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Provider.of<MainProvider>(context, listen: false).clearSelectedVerses();
      });
    }
  }

  @override
  void dispose() {
    _fakeScrollController.dispose();
    Provider.of<MainProvider>(context, listen: false).clearSelectedVerses();
    super.dispose();
  }

  String formattedSelectedVerses({required List<Verse> verses}) {
    final settings = Provider.of<AppSettings>(context, listen: false);
    final notePattern = RegExp(r'<note:[^>]*>');
    final braceInnerPattern = RegExp(r'\{([^}]*)\}');
    final squareInnerPattern = RegExp(r'\[([^\]]*)\]');
    final sorted = [...verses]..sort((a, b) {
        final bookComparison = a.book.compareTo(b.book);
        if (bookComparison != 0) return bookComparison;
        if (a.chapter != b.chapter) return a.chapter.compareTo(b.chapter);
        return a.verse.compareTo(b.verse);
      });

    if (sorted.isEmpty) return '';

    final first = sorted.first;
    final header = '${first.book} ${first.chapter}';

    switch (settings.copyFormat) {
      case 'withRef':
        return sorted
            .map((v) {
              final cleanedText = v.text
                .replaceAll(notePattern, '')
                .replaceAllMapped(braceInnerPattern, (m) => m.group(1) ?? '')
                .replaceAllMapped(squareInnerPattern, (m) => m.group(1) ?? '')
                .trim();
              return '[${v.book} ${v.chapter}:${v.verse}] $cleanedText';
            })
            .join('\n');
      case 'plain':
        return '$header\n' +
            sorted
                .map((v) {
                  final cleanedText = v.text
                    .replaceAll(notePattern, '')
                    .replaceAllMapped(braceInnerPattern, (m) => m.group(1) ?? '')
                    .replaceAllMapped(squareInnerPattern, (m) => m.group(1) ?? '')
                    .trim();
                  return '${v.verse} $cleanedText';
                })
                .join('\n');
      case 'devotional':
        final book = first.book;
        final chapter = first.chapter;
        final versesText = sorted
            .map((v) =>
                v.text.replaceAll(notePattern, '') 
                    .replaceAllMapped(braceInnerPattern, (m) => m.group(1) ?? '')
                    .replaceAllMapped(squareInnerPattern, (m) => m.group(1) ?? '')
                    .trim())
            .join('\n');
        final verseNumbers = sorted.map((v) => v.verse).toList();

        String formatRange(List<int> nums) {
          if (nums.isEmpty) return '';
          nums.sort();
          final List<String> parts = [];
          int start = nums[0];
          int end = start;

          for (int i = 1; i < nums.length; i++) {
            if (nums[i] == end + 1) {
              end = nums[i];
            } else {
              if (start == end) {
                parts.add('$start');
              } else {
                parts.add('$start‚Äì$end');
              }
              start = nums[i];
              end = start;
            }
          }

          if (start == end) {
            parts.add('$start');
          } else {
            parts.add('$start‚Äì$end');
          }

          return parts.join(', ');
        }

        final range = formatRange(verseNumbers);
        return '$versesText\n($book $chapter:$range)';
      default:
        return sorted
            .map((v) => v.text.replaceAll(notePattern, '')
                .replaceAllMapped(braceInnerPattern, (m) => m.group(1) ?? '')
                .replaceAllMapped(squareInnerPattern, (m) => m.group(1) ?? '')
                .trim())
            .join('\n');
    }
  }

  List<InlineSpan> _buildVerseSpans(List<Verse> verses, BuildContext context) {
    final settings = Provider.of<AppSettings>(context, listen: false);
    final spans = <InlineSpan>[];
    final bracePattern = RegExp(r'\{([^}]+)\}');
    final notePattern  = RegExp(r'<note:([^>]+)>');

    for (var v in verses) {
      // Verse number
      spans.add(WidgetSpan(
        child: GestureDetector(
          onTap: () async {
            final original = v.text.replaceAll('\n', '');
            final sanitized = original.replaceAll(notePattern, '').replaceAll(bracePattern, '').trim();
            final toCopy = '${v.verse} $sanitized';
            await ClipboardHelper.copyText(toCopy);
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Copied verse ${v.verse}')),
            );
          },
          child: Text(
            '${v.verse} ',
            style: TextStyle(
              color: Theme.of(context).colorScheme.primary,
              fontSize: settings.fontSize,
              fontFamily: settings.fontFamily,
              height: settings.lineSpacing,
            ),
          ),
        ),
      ));

      // Prepare original text and extract notes
      final original = v.text.replaceAll('\n', '');
      // Remove note tags from display
      final raw = original.replaceAll(notePattern, '').trim();
      // Split on curly annotations, preserving them for badge rendering
      final parts = raw.splitMapJoin(
        bracePattern,
        onMatch: (m) => '||${m[0]}||',
        onNonMatch: (n) => n,
      ).split('||');

      for (var part in parts) {
        if (bracePattern.hasMatch(part)) {
          final annotation = bracePattern.firstMatch(part)!.group(1)!;
          // Retrieve the first note from the original full text
          final noteMatch = notePattern.firstMatch(original);
          final noteText  = noteMatch != null ? noteMatch.group(1)! : '';

          spans.add(WidgetSpan(
            alignment: PlaceholderAlignment.middle,
            child: GestureDetector(
              onTap: () {
                showDialog(
                  context: context,
                  builder: (_) => AlertDialog(
                    title: Text('Note'),
                    content: Text(noteText),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: Text('Close'),
                      ),
                    ],
                  ),
                );
              },
              child: Container(
                padding: EdgeInsets.symmetric(horizontal: 6, vertical: 3),
                margin: EdgeInsets.symmetric(horizontal: 2),
                decoration: BoxDecoration(
                  color: Theme.of(context)
                      .colorScheme
                      .secondary
                      .withOpacity(0.3),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  annotation,
                  style: TextStyle(
                    fontSize: settings.fontSize * 0.85,
                    fontFamily: settings.fontFamily,
                    height: settings.lineSpacing,
                  ),
                ),
              ),
            ),
          ));
        } else {
          spans.add(TextSpan(
            text: part,
            style: TextStyle(
              fontSize: settings.fontSize,
              fontFamily: settings.fontFamily,
              height: settings.lineSpacing,
              color: Theme.of(context).textTheme.bodyMedium?.color,
            ),
          ));
        }
      }
    }

    return spans;
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<MainProvider, AppSettings>(
      builder: (context, mainProvider, settings, child) {
        final verses = mainProvider.verses
            .where((v) =>
                v.book == mainProvider.currentBook &&
                v.chapter == mainProvider.currentChapter)
            .toList()
          ..sort((a, b) => a.verse.compareTo(b.verse));

        // (groupVersesIntoParagraphs local function removed)

        // final paragraphs = _groupVersesIntoParagraphs(verses);
        final currentVerse = mainProvider.currentVerse ??
            (verses.isNotEmpty ? verses.first : null);
        final isSelected = mainProvider.selectedVerses.isNotEmpty;

        return SelectionArea(
          child: GestureDetector(
            onHorizontalDragEnd: (details) {
              if (details.primaryVelocity! < 0) {
                _goToNextChapter();
              } else if (details.primaryVelocity! > 0) {
                _goToPreviousChapter();
              }
            },
            child: AnnotatedRegion<SystemUiOverlayStyle>(
              value: SystemUiOverlayStyle(
                systemNavigationBarColor:
                    Theme.of(context).colorScheme.background,
                systemNavigationBarIconBrightness:
                    Theme.of(context).brightness == Brightness.dark
                        ? Brightness.light
                        : Brightness.dark,
              ),
              child: Scaffold(
                floatingActionButtonAnimator: NoScalingAnimation(),
                appBar: AppBar(
                  title: LayoutBuilder(
                    builder: (context, constraints) {
                      // double scale =
                      //     (constraints.maxWidth / 375).clamp(0.75, 1.0);
                      double baseFontSize =
                          Theme.of(context).textTheme.titleLarge?.fontSize ??
                              20;
                      if (currentVerse == null) {
                        return Text(
                          uiStrings['bible']?[settings.locale] ?? 'Bible',
                          style: TextStyle(
                            fontSize: baseFontSize,
                            fontFamily: settings.fontFamily,
                          ),
                        );
                      }
                      return FittedBox(
                        fit: BoxFit.scaleDown,
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Material(
                              color: Colors.transparent,
                              child: InkWell(
                                borderRadius: BorderRadius.circular(8),
                                onTap: () {
                                  final mainProvider =
                                      Provider.of<MainProvider>(context,
                                          listen: false);
                                  mainProvider.clearSelectedVerses();
                                  Get.to(
                                    () => BooksPage(
                                      chapterIdx:
                                          mainProvider.currentVerse?.chapter ??
                                              1,
                                      bookIdx:
                                          mainProvider.currentVerse?.book ?? '',
                                    ),
                                    transition: Transition.leftToRight,
                                    duration: const Duration(milliseconds: 300),
                                    curve: Curves.easeInOut,
                                  );
                                },
                                child: Padding(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 4, vertical: 2),
                                  child: Text(
                                    '${currentVerse.book} ${currentVerse.chapter}',
                                    style: TextStyle(
                                      fontFamily: settings.fontFamily,
                                      fontSize: settings.fontSize,
                                      fontWeight: FontWeight.w600,
                                      color:
                                          Theme.of(context).colorScheme.primary,
                                    ),
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(width: 8),
                            PopupMenuButton<String>(
                              padding: EdgeInsets.zero,
                              tooltip: uiStrings['changeVersion']
                                      ?[settings.locale] ??
                                  'Change Version',
                              child: Padding(
                                padding:
                                    const EdgeInsets.symmetric(horizontal: 4),
                                child: Text(
                                  {
                                        'kjv': 'KJV',
                                        'leb': 'LEB',
                                        'cuvs-yhwh': 'cuvs(ÁÆÄ)',
                                        'cuvs-yhwh-tr': 'cuvs(ÁπÅ)',
                                        'BIBLEXG': 'biblexg(ÁÆÄ)',
                                        'BIBLEXG-tr': 'biblexg(ÁπÅ)',
                                      }[mainProvider.currentVersion] ??
                                      mainProvider.currentVersion,
                                  style: TextStyle(
                                    fontFamily: settings.fontFamily,
                                    fontSize: settings.fontSize,
                                    fontWeight: FontWeight.w600,
                                    color:
                                        Theme.of(context).colorScheme.primary,
                                  ),
                                ),
                              ),
                              onSelected: (version) async {
                                final p = context.read<MainProvider>();
                                final settings = Provider.of<AppSettings>(
                                    context,
                                    listen: false);
                                p.clearSelectedVerses();

                                final prevEn = toEnglish(p.currentBook);

                                p.setVersion(version);
                                await FetchVerses.execute(
                                    mainProvider: p, settings: settings);
                                await FetchBooks.execute(
                                    mainProvider: p, settings: settings);

                                String? targetBook = prevEn == null
                                    ? null
                                    : translateBookName(prevEn, version);

                                final match = p.verses.firstWhere(
                                  (v) =>
                                      v.book ==
                                          (targetBook ?? p.verses.first.book) &&
                                      v.chapter ==
                                          (p.currentChapter ?? v.chapter),
                                  orElse: () => p.verses.first,
                                );

                                p.setCurrentChapter(
                                    book: match.book, chapter: match.chapter);
                                p.updateCurrentVerse(verse: match);
                              },
                              itemBuilder: (context) => const [
                                PopupMenuItem(
                                    value: 'kjv',
                                    child: Text('King James Version')),
                                PopupMenuItem(
                                    value: 'leb',
                                    child: Text('Lexham English Bible'),),
                                PopupMenuItem(
                                    value: 'cuvs-yhwh',
                                    child: Text('ÂíåÂêàÊú¨ÈõÖ‰ºüÁâà(ÁÆÄ‰Ωì)')),
                                PopupMenuItem(
                                    value: 'cuvs-yhwh-tr',
                                    child: Text('ÂíåÂêàÊú¨ÈõÖ‰ºüÁâà(ÁπÅÈ´î)')),
                                PopupMenuItem(
                                    value: 'BIBLEXG', child: Text('Ê¢ÅÂÆ∂ÈìøËØëÊú¨(ÁÆÄ‰Ωì)')),
                                PopupMenuItem(
                                    value: 'BIBLEXG-tr',
                                    child: Text('Ê¢ÅÂÆ∂ÈìøË≠ØÊú¨(ÁπÅÈ´î)')),
                              ],
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                  actions: [
                    LayoutBuilder(
                      builder: (context, constraints) {
                        if (constraints.maxWidth < 377) {
                          return PopupMenuButton<String>(
                            icon: const Icon(Icons.more_vert),
                            onSelected: (value) async {
                              if (value == 'search') {
                                mainProvider.clearSelectedVerses();
                                Get.to(
                                  () => SearchPage(),
                                  transition: Transition.rightToLeft,
                                );
                              }
                            },
                            itemBuilder: (context) => [
                              PopupMenuItem<String>(
                                value: 'search',
                                child: ListTile(
                                  leading: Icon(Icons.search),
                                  title: Text(uiStrings['search']
                                          ?[settings.locale] ??
                                      'Search'),
                                ),
                              ),
                            ],
                          );
                        } else {
                          double screenWidth =
                              MediaQuery.of(context).size.width;
                          double scale = (screenWidth / 375).clamp(0.5, 1.0);
                          double baseFontSize = Theme.of(context)
                                  .textTheme
                                  .titleLarge
                                  ?.fontSize ??
                              20;
                          // Use padding and constrained box to limit right margin and width
                          return Padding(
                            padding: const EdgeInsets.only(right: 8),
                            child: ConstrainedBox(
                              constraints: const BoxConstraints(maxWidth: 120),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Transform.scale(
                                    scale: scale,
                                    child: IconButton(
                                      padding: EdgeInsets.all(8.0 * scale),
                                      constraints: const BoxConstraints(),
                                      icon: Icon(Icons.search_rounded,
                                          size: baseFontSize * scale),
                                      onPressed: () {
                                        mainProvider.clearSelectedVerses();
                                        Get.to(
                                          () => SearchPage(),
                                          transition: Transition.rightToLeft,
                                        );
                                      },
                                    ),
                                  ),
                                  SizedBox(width: 2 * scale),
                                  Transform.scale(
                                    scale: scale,
                                    child: IconButton(
                                      padding: EdgeInsets.all(8.0 * scale),
                                      constraints: const BoxConstraints(),
                                      icon: Icon(Icons.settings,
                                          size: baseFontSize * scale),
                                      onPressed: () {
                                        mainProvider.clearSelectedVerses();
                                        Get.to(() => SettingsPage());
                                      },
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          );
                        }
                      },
                    ),
                  ],
                ),
                body: Stack(
                  children: [
                    Padding(
                      padding: const EdgeInsets.only(right: 8.0),
                      child: settings.readingModeCentered
                          ? SingleChildScrollView(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 16.0, vertical: 12.0),
                              child: Text.rich(
                                TextSpan(
                                    children:
                                        _buildVerseSpans(verses, context)),
                              ),
                            )
                          : Scrollbar(
                              controller: _fakeScrollController,
                              child: ScrollablePositionedList.builder(
                                itemCount: verses.length + 1,
                                itemBuilder: (context, index) {
                                  if (index < verses.length) {
                                    return VerseWidget(
                                      verse: verses[index],
                                      index: index,
                                    );
                                  }
                                  return const SizedBox(height: 120);
                                },
                                itemScrollController:
                                    mainProvider.itemScrollController,
                                itemPositionsListener:
                                    mainProvider.itemPositionsListener,
                                scrollOffsetController:
                                    mainProvider.scrollOffsetController,
                                scrollOffsetListener:
                                    mainProvider.scrollOffsetListener,
                              ),
                            ),
                    ),
                  ],
                ),
                floatingActionButton: isSelected
                    ? FloatingActionButton(
                        onPressed: () async {
                          final text = formattedSelectedVerses(
                              verses: mainProvider.selectedVerses);
                          await FlutterClipboard.copy(text);
                          mainProvider.clearSelectedVerses();
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Row(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Text(
                                    uiStrings['copied']?[settings.locale] ??
                                        'Copied!',
                                    style: TextStyle(
                                      color: Theme.of(context)
                                          .colorScheme
                                          .onPrimary,
                                      fontWeight: FontWeight.w600,
                                    ),
                                  ),
                                ],
                              ),
                              backgroundColor: Theme.of(context)
                                  .colorScheme
                                  .primary
                                  .withOpacity(0.8),
                              duration: Duration(milliseconds: 800),
                            ),
                          );
                        },
                        child: const Icon(Icons.copy_rounded),
                      )
                    : null,
                floatingActionButtonLocation:
                    CustomFloatingActionButtonLocation(
                  xOffset: -16,
                  yOffset: -16,
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  void _goToNextChapter() {
    final provider = Provider.of<MainProvider>(context, listen: false);
    provider.clearSelectedVerses();
    final books = provider.books;
    final currentBook = provider.currentBook;
    final currentChapter = provider.currentChapter;
    if (currentBook == null || currentChapter == null) return;

    // ÊâæÂà∞ÂΩìÂâç‰π¶Âç∑Âú®ÂàóË°®‰∏≠ÁöÑÁ¥¢Âºï
    final bookIdx = books.indexWhere((b) => b.title == currentBook);
    if (bookIdx < 0) return;
    final chapters = books[bookIdx].chapters;
    final chapIdx = chapters.indexWhere((c) => c.title == currentChapter);
    String nextBook;
    int nextChap;
    if (chapIdx < chapters.length - 1) {
      nextBook = currentBook;
      nextChap = chapters[chapIdx + 1].title;
    } else {
      final nextBookIdx = (bookIdx + 1) % books.length;
      nextBook = books[nextBookIdx].title;
      nextChap = books[nextBookIdx].chapters.first.title;
    }

    _switchTo(provider, nextBook, nextChap);
  }

  void _goToPreviousChapter() {
    final provider = Provider.of<MainProvider>(context, listen: false);
    provider.clearSelectedVerses();
    final books = provider.books;
    final currentBook = provider.currentBook;
    final currentChapter = provider.currentChapter;
    if (currentBook == null || currentChapter == null) return;

    final bookIdx = books.indexWhere((b) => b.title == currentBook);
    if (bookIdx < 0) return;
    final chapters = books[bookIdx].chapters;
    final chapIdx = chapters.indexWhere((c) => c.title == currentChapter);
    String prevBook;
    int prevChap;
    if (chapIdx > 0) {
      prevBook = currentBook;
      prevChap = chapters[chapIdx - 1].title;
    } else {
      final prevBookIdx = (bookIdx - 1 + books.length) % books.length;
      prevBook = books[prevBookIdx].title;
      prevChap = books[prevBookIdx].chapters.last.title;
    }

    _switchTo(provider, prevBook, prevChap);
  }

  void _switchTo(MainProvider provider, String book, int chap) {
    final matched = provider.verses
        .where((v) => v.book == book && v.chapter == chap)
        .toList();

    final first = matched.isNotEmpty ? matched.first : provider.verses.first;
    provider.setCurrentChapter(book: book, chapter: chap);
    provider.updateCurrentVerse(verse: first);

    provider.jumpToIndex(index: 0); 
  }

  List<List<Verse>> _groupVersesIntoParagraphs(List<Verse> verses) {
    final List<List<Verse>> paragraphs = [];
    List<Verse> current = [];
    for (var v in verses) {
      if (current.isEmpty ||
          v.verse == 1 ||
          v.verse > (current.last.verse + 1)) {
        if (current.isNotEmpty) paragraphs.add(current);
        current = [v];
      } else {
        current.add(v);
      }
    }
    if (current.isNotEmpty) paragraphs.add(current);
    return paragraphs;
  }
}

class NoScalingAnimation extends FloatingActionButtonAnimator {
  @override
  Offset getOffset(
      {required Offset begin, required Offset end, required double progress}) {
    return Offset.lerp(begin, end, 1)!; // Instantly move without animation
  }

  @override
  Animation<double> getRotationAnimation({required Animation<double> parent}) {
    return AlwaysStoppedAnimation(1); // No rotation
  }

  @override
  Animation<double> getScaleAnimation({required Animation<double> parent}) {
    return AlwaysStoppedAnimation(1); // No scaling animation
  }
}


================================================================================
FILE: pages/settings_page.dart
================================================================================
import 'package:flutter/material.dart';
// import 'package:http/http.dart' as http;
import 'package:yswords/constants/ui_strings.dart';
// import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:yswords/models/app_settings.dart';
import 'package:yswords/providers/main_provider.dart';

import 'package:yswords/widgets/localized_back_button.dart';


String getDevotionalFormattedText(
    List<Map<String, dynamic>> verses, String? book, int? chapter) {
  if (verses.isEmpty || book == null || chapter == null) return '';

  List<int> verseNums = verses.map((v) => v['verse'] as int).toList()..sort();
  List<String> textParts = verses
      .map((v) => v['text'] as String)
      .toList();

  // Build reference string
  List<String> ranges = [];
  for (int i = 0; i < verseNums.length;) {
    int start = verseNums[i];
    int end = start;
    while (i + 1 < verseNums.length && verseNums[i + 1] == end + 1) {
      end = verseNums[++i];
    }
    ranges.add(start == end ? '$start' : '$start‚Äì$end');
    i++;
  }

  final ref = '$book $chapter:${ranges.join(',')}';
  final fullText = textParts.join('\n');
  return '$fullText\n($ref)';
}

class SettingsPage extends StatelessWidget {
  SettingsPage({super.key});

  // final TextEditingController _feedbackController = TextEditingController();
  // final ValueNotifier<bool> _isSending = ValueNotifier(false);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: const LocalizedBackButton(),
        // The settings locale is now available inside the Consumer below
        title: Consumer<AppSettings>(
          builder: (context, settings, _) =>
              Text(uiStrings['settings']?[settings.locale] ?? 'Settings'),
        ),
      ),
      body: Consumer<AppSettings>(
        builder: (context, settings, _) {
          final mainProvider = Provider.of<MainProvider>(context);
          final currentBook = mainProvider.currentBook;
          final currentChapter = mainProvider.currentChapter;

          final List<Color> palette = [
            Colors.red,
            Colors.deepOrange,
            Colors.orange,
            Colors.amber,
            Colors.yellow,
            Colors.lime,
            Colors.lightGreen,
            Colors.green,
            Colors.teal,
            Colors.cyan,
            Colors.lightBlue,
            Colors.blue,
            Colors.indigo,
            Colors.deepPurple,
            Colors.purple,
            Colors.pink,
            Colors.brown,
            Colors.grey,
            Colors.blueGrey,
          ];

          final versesInChapter = mainProvider.verses
              .where((v) => v.book == currentBook && v.chapter == currentChapter)
              .toList()
            ..sort((a, b) => a.verse.compareTo(b.verse));
          final verseSamples = versesInChapter
              .take(3)
              .map((v) => {'verse': v.verse, 'text': v.text})
              .toList();

          return ListView(
            padding: const EdgeInsets.all(16),
            children: [
              Card(
                child: Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        uiStrings['fontSize']?[settings.locale] ?? 'Font Size',
                        style: TextStyle(
                          fontFamily: settings.fontFamily,
                          fontSize: settings.fontSize + 2,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      Slider(
                        value: settings.fontSize,
                        min: 12,
                        max: 40,
                        divisions: 28,
                        label: '${settings.fontSize.toInt()} pt',
                        onChanged: (val) => settings.setFontSize(val),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Card(
                child: Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        uiStrings['lineSpacing']?[settings.locale] ??
                            'Line Spacing',
                        style: TextStyle(
                          fontFamily: settings.fontFamily,
                          fontSize: settings.fontSize + 2,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      Slider(
                        value: settings.lineSpacing,
                        min: 1.0,
                        max: 3.0,
                        divisions: 20,
                        label: settings.lineSpacing.toStringAsFixed(1),
                        onChanged: (val) => settings.setLineSpacing(
                            double.parse(val.toStringAsFixed(1))),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        uiStrings['samplePreview']?[settings.locale] ??
                            'Sample Preview',
                        style: TextStyle(
                          fontFamily: settings.fontFamily,
                          fontSize: settings.fontSize + 2,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 12),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            uiStrings['copyFormat']?[settings.locale] ??
                                'Copy Format',
                            style: TextStyle(
                              fontFamily: settings.fontFamily,
                              fontSize: settings.fontSize + 2,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          const SizedBox(height: 8),
                          DropdownButton<String>(
                            value: settings.copyFormat,
                            onChanged: (val) {
                              if (val != null) settings.setCopyFormat(val);
                            },
                            items: [
                              DropdownMenuItem(
                                  value: 'plain',
                                  child: Text(
                                    uiStrings['plainText']?[settings.locale] ??
                                        'Plain Text',
                                    style: TextStyle(
                                      fontSize: settings.fontSize,
                                      fontFamily: settings.fontFamily,
                                    ),
                                  )),
                              DropdownMenuItem(
                                  value: 'withRef',
                                  child: Text(
                                    uiStrings['withReference']
                                            ?[settings.locale] ??
                                        'With Reference',
                                    style: TextStyle(
                                      fontSize: settings.fontSize,
                                      fontFamily: settings.fontFamily,
                                    ),
                                  )),
                              DropdownMenuItem(
                                  value: 'devotional',
                                  child: Text(
                                    uiStrings['devotionalFormat']
                                            ?[settings.locale] ??
                                        'Devotional Format',
                                    style: TextStyle(
                                      fontSize: settings.fontSize,
                                      fontFamily: settings.fontFamily,
                                    ),
                                  )),
                            ],
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      Text(
                        '$currentBook $currentChapter',
                        style:
                            Theme.of(context).textTheme.titleMedium?.copyWith(
                                  fontFamily: settings.fontFamily,
                                  fontWeight: FontWeight.bold,
                                  color: Theme.of(context).colorScheme.primary,
                                  fontSize: settings.fontSize,
                                ),
                      ),
                      const SizedBox(height: 8),
                      const SizedBox(height: 12),
                      if (settings.copyFormat == 'devotional')
                        Padding(
                          padding:
                              EdgeInsets.only(bottom: settings.lineSpacing * 2),
                          child: RichText(
                            text: TextSpan(
                              style: TextStyle(
                                fontSize: settings.fontSize,
                                fontFamily: settings.fontFamily,
                                height: settings.lineSpacing,
                                color: Theme.of(context)
                                    .textTheme
                                    .bodyMedium
                                    ?.color,
                              ),
                              children: [
                                TextSpan(
                                  text: getDevotionalFormattedText(verseSamples,
                                      currentBook, currentChapter),
                                ),
                              ],
                            ),
                          ),
                        )
                      else
                        ...verseSamples.map((v) {
                          final ref =
                              '${currentBook ?? ''} ${currentChapter}:${v['verse']}';
                          String formattedText;
                          switch (settings.copyFormat) {
                            case 'withRef':
                              formattedText = '[$ref] ${v['text']}';
                              break;
                            case 'plain':
                            default:
                              formattedText = '${v['verse']} ${v['text']}';
                          }
                          final cleanedText = formattedText
                              .replaceAll(RegExp(r'<[^>]*>'), '')
                              .replaceAll(RegExp(r'\{[^}]*\}'), '');

                          return Padding(
                            padding: EdgeInsets.only(
                                bottom: settings.lineSpacing * 2),
                            child: RichText(
                              text: TextSpan(
                                style: TextStyle(
                                  fontSize: settings.fontSize,
                                  fontFamily: settings.fontFamily,
                                  height: settings.lineSpacing,
                                  color: Theme.of(context)
                                      .textTheme
                                      .bodyMedium
                                      ?.color,
                                ),
                                children: [
                                  if (settings.copyFormat == 'plain') ...[
                                    TextSpan(
                                      text: '${v['verse']} ',
                                      style: TextStyle(
                                        fontWeight: FontWeight.bold,
                                        color: Theme.of(context)
                                            .colorScheme
                                            .primary,
                                      ),
                                    ),
                                    TextSpan(
                                      text: v['text']
                                          .toString()
                                          .replaceAll(RegExp(r'<[^>]*>'), '')
                                          .replaceAll(RegExp(r'\{[^}]*\}'), ''),
                                    ),
                                  ] else ...[
                                    TextSpan(text: cleanedText),
                                  ],
                                ],
                              ),
                            ),
                          );
                        }),
                      // Removed Copy Preview button and its padding
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Card(
                child: Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        uiStrings['fontFamily']?[settings.locale] ??
                            'Font Family',
                        style: TextStyle(
                          fontFamily: settings.fontFamily,
                          fontSize: settings.fontSize + 2,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 12),
                      DropdownButton<String>(
                        value: settings.fontFamily,
                        onChanged: (val) {
                          if (val != null) settings.setFontFamily(val);
                        },
                        items: [
                          DropdownMenuItem(
                            value: 'Roboto',
                            child: Text('Roboto',
                                style: TextStyle(
                                  fontSize: settings.fontSize,
                                  fontFamily: 'Roboto',
                                )),
                          ),
                          DropdownMenuItem(
                            value: 'Microsoft YaHei',
                            child: Text('Microsoft YaHei',
                                style: TextStyle(
                                  fontSize: settings.fontSize,
                                  fontFamily: 'Microsoft Yahei',
                                )),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              // --- Reading/Study Mode Toggle ---
              // Card(
              //   child: Padding(
              //     padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              //     child: Column(
              //       crossAxisAlignment: CrossAxisAlignment.start,
              //       children: [
              //         Text(
              //           'ÈòÖËØªÊ®°ÂºèÊéíÁâà',
              //           style: TextStyle(
              //             fontFamily: settings.fontFamily,
              //             fontSize: settings.fontSize + 2,
              //             fontWeight: FontWeight.w600,
              //           ),
              //         ),
              //         const SizedBox(height: 12),
              //         SwitchListTile(
              //           contentPadding: EdgeInsets.zero,
              //           title: Text(
              //             settings.readingModeCentered ? 'ÈòÖËØªÂûãÔºàÂ±Ö‰∏≠„ÄÅÊÆµËêΩÔºâ' : 'Êü•ÁªèÂûãÔºàÂ∑¶ÂØπÈΩê„ÄÅ‰∏ÄËäÇ‰∏ÄË°åÔºâ',
              //             style: TextStyle(
              //               fontFamily: settings.fontFamily,
              //               fontSize: settings.fontSize,
              //             ),
              //           ),
              //           value: settings.readingModeCentered,
              //           onChanged: (val) => settings.setReadingModeCentered(val),
              //         ),
              //       ],
              //     ),
              //   ),
              // ),
              // const SizedBox(height: 16),
              if (Theme.of(context).brightness != Brightness.dark) ...[
                Card(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16, vertical: 12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          uiStrings['primaryColor']?[settings.locale] ??
                              'Primary Color',
                          style: TextStyle(
                            fontFamily: settings.fontFamily,
                            fontSize: settings.fontSize + 2,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 12),
                        Wrap(
                          spacing: 8,
                          runSpacing: 8,
                          children: palette.map((c) {
                            return GestureDetector(
                              onTap: () => settings.setPrimaryColor(c),
                              child: CircleAvatar(
                                backgroundColor: c,
                                radius: settings.fontSize * 0.8,
                                child: settings.primaryColor == c
                                    ? Icon(Icons.check,
                                        color: Colors.white,
                                        size: settings.fontSize * 0.6)
                                    : null,
                              ),
                            );
                          }).toList(),
                        ),
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 16),
              ],
              Card(
                child: Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        uiStrings['themeMode']?[settings.locale] ??
                            'Theme Mode',
                        style: TextStyle(
                          fontFamily: settings.fontFamily,
                          fontSize: settings.fontSize + 2,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 12),
                      DropdownButton<ThemeMode>(
                        value: settings.themeMode,
                        onChanged: (val) {
                          if (val != null) settings.setThemeMode(val);
                        },
                        items: [
                          DropdownMenuItem(
                            value: ThemeMode.system,
                            child: Text(
                              uiStrings['themeSystem']?[settings.locale] ??
                                  'Ë∑üÈö®Á≥ªÁµ±',
                              style: TextStyle(
                                fontSize: settings.fontSize,
                                fontFamily: settings.fontFamily,
                              ),
                            ),
                          ),
                          DropdownMenuItem(
                            value: ThemeMode.light,
                            child: Text(
                              uiStrings['themeDay']?[settings.locale] ?? 'ÁôΩÂ§©Ê®°Âºè',
                              style: TextStyle(
                                fontSize: settings.fontSize,
                                fontFamily: settings.fontFamily,
                              ),
                            ),
                          ),
                          DropdownMenuItem(
                            value: ThemeMode.dark,
                            child: Text(
                              uiStrings['themeNight']?[settings.locale] ??
                                  'Â§úÈñìÊ®°Âºè',
                              style: TextStyle(
                                fontSize: settings.fontSize,
                                fontFamily: settings.fontFamily,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              // Only show these settings when running as Web App
              // if (kIsWeb && !settings.lockAllowUpdates)
              //   Card(
              //     // margin: const EdgeInsets.only(top: 24),
              //     child: SwitchListTile(
              //       title: Text(
              //         uiStrings['allowUpdates']?[settings.locale] ??
              //             'Allow Auto Updates',
              //         style: TextStyle(
              //           fontSize: settings.fontSize + 2,
              //           fontWeight: FontWeight.w600,
              //         ),
              //       ),
              //       subtitle: Text(
              //         uiStrings['allowUpdatesSubtitle']?[settings.locale] ??
              //             'Toggle whether to allow app updates from server.',
              //         style: TextStyle(
              //           fontSize: settings.fontSize,
              //           fontFamily: settings.fontFamily,
              //         ),
              //       ),
              //       value: settings.allowUpdates,
              //       onChanged: (val) {
              //         settings.setAllowUpdates(val);
              //       },
              //     ),
              //   ),
              // const SizedBox(height: 16),
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        uiStrings['interfaceLanguage']?[settings.locale] ??
                            'ÁïåÈù¢ËØ≠Ë®Ä',
                        style: TextStyle(
                          fontFamily: settings.fontFamily,
                          fontSize: settings.fontSize + 2,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 8),
                      DropdownButton<String>(
                        value: settings.locale,
                        onChanged: (val) {
                          if (val != null) settings.setLocale(val);
                        },
                        items: [
                          DropdownMenuItem(
                            value: 'zh-Hans',
                            child: Text('ÁÆÄ‰Ωì‰∏≠Êñá',
                                style: TextStyle(
                                  fontSize: settings.fontSize,
                                  fontFamily: settings.fontFamily,
                                )),
                          ),
                          DropdownMenuItem(
                            value: 'zh-Hant',
                            child: Text('ÁπÅÈ´î‰∏≠Êñá',
                                style: TextStyle(
                                  fontSize: settings.fontSize,
                                  fontFamily: settings.fontFamily,
                                )),
                          ),
                          DropdownMenuItem(
                            value: 'en',
                            child: Text('English',
                                style: TextStyle(
                                  fontSize: settings.fontSize,
                                  fontFamily: settings.fontFamily,
                                )),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              // --- Áõ¥Êé•Âú® App ÂÖßËº∏ÂÖ•‰∏¶ÁôºÈÄÅÂèçÈ•ãÁöÑÂçÄÂ°ä ---
//               Card(
//                 child: Padding(
//                   padding: const EdgeInsets.all(16),
//                   child: Column(
//                     crossAxisAlignment: CrossAxisAlignment.start,
//                     children: [
//                       Text(
//                         uiStrings['sendFeedback']?[settings.locale] ??
//                             'Send Feedback',
//                         style: TextStyle(
//                           fontFamily: settings.fontFamily,
//                           fontSize: settings.fontSize + 2,
//                           fontWeight: FontWeight.w600,
//                         ),
//                       ),
//                       const SizedBox(height: 12),
//                       TextFormField(
//                         controller: _feedbackController,
//                         style: TextStyle(
//                           fontSize: settings.fontSize,
//                           fontFamily: settings.fontFamily,
//                         ),
//                         maxLines: null,
//                         maxLength: 500,
//                         decoration: InputDecoration(
//                           hintText: uiStrings['feedbackHint']
//                                   ?[settings.locale] ??
//                               'Please enter your feedback...',
//                           hintStyle: TextStyle(
//                             fontSize: settings.fontSize,
//                             fontFamily: settings.fontFamily,
//                           ),
//                           counterStyle: TextStyle(
//                             fontSize: settings.fontSize,
//                             fontFamily: settings.fontFamily,
//                           ),
//                           border: const OutlineInputBorder(),
//                         ),
//                       ),
//                       const SizedBox(height: 12),
//                       SizedBox(
//                         width: double.infinity,
//                         child: ValueListenableBuilder<bool>(
//                           valueListenable: _isSending,
//                           builder: (context, isSending, child) {
//                             return ElevatedButton.icon(
//                               style: Theme.of(context).brightness ==
//                                       Brightness.light
//                                   ? ElevatedButton.styleFrom(
//                                       backgroundColor:
//                                           Theme.of(context).colorScheme.primary,
//                                       foregroundColor: Colors.white,
//                                       padding: const EdgeInsets.symmetric(
//                                           vertical: 16),
//                                       textStyle: TextStyle(
//                                         fontSize: settings.fontSize + 2,
//                                         fontWeight: FontWeight.bold,
//                                         fontFamily: settings.fontFamily,
//                                       ),
//                                     )
//                                   : null,
//                               icon: isSending
//                                   ? const SizedBox(
//                                       width: 16,
//                                       height: 16,
//                                       child: CircularProgressIndicator(
//                                         strokeWidth: 2,
//                                         valueColor:
//                                             AlwaysStoppedAnimation<Color>(
//                                                 Colors.white),
//                                       ),
//                                     )
//                                   : const Icon(Icons.send),
//                               label: Text(
//                                 isSending
//                                     ? (uiStrings['sendingFeedback']
//                                             ?[settings.locale] ??
//                                         'Sending...')
//                                     : (uiStrings['sendFeedback']
//                                             ?[settings.locale] ??
//                                         'Send Feedback'),
//                                 style: TextStyle(
//                                   fontFamily: settings.fontFamily,
//                                   fontSize: settings.fontSize,
//                                 ),
//                               ),
//                               onPressed: isSending
//                                   ? null
//                                   : () async {
//                                       final content =
//                                           _feedbackController.text.trim();
//                                       if (content.isEmpty) {
//                                         ScaffoldMessenger.of(context)
//                                             .showSnackBar(
//                                           SnackBar(
//                                             content: Text(
//                                               uiStrings['feedbackEmpty']
//                                                       ?[settings.locale] ??
//                                                   'Ë´ãËº∏ÂÖ•ÂèçÈ•ãÂÖßÂÆπ',
//                                               style: TextStyle(
//                                                 fontFamily: settings.fontFamily,
//                                                 fontSize: settings.fontSize,
//                                               ),
//                                             ),
//                                             duration:
//                                                 Duration(milliseconds: 1500),
//                                           ),
//                                         );
//                                         return;
//                                       }
//                                       if (content.length > 500) {
//                                         ScaffoldMessenger.of(context)
//                                             .showSnackBar(
//                                           SnackBar(
//                                             content: Text(
//                                               uiStrings['feedbackTooLong']
//                                                       ?[settings.locale] ??
//                                                   'ÂÖßÂÆπÈÅéÈï∑ÔºåË´ãÂà™Ê∏õÂæåÂÜçÁôºÈÄÅ„ÄÇ',
//                                               style: TextStyle(
//                                                 fontFamily: settings.fontFamily,
//                                                 fontSize: settings.fontSize,
//                                               ),
//                                             ),
//                                             duration:
//                                                 Duration(milliseconds: 1500),
//                                           ),
//                                         );
//                                         return;
//                                       }

//                                       final emojiRegex = RegExp(
//                                         r'[\u{1F600}-\u{1F64F}]|' // Emoticons Ë°®ÊÉÖÁ¨¶Ëôü
//                                         r'[\u{1F300}-\u{1F5FF}]|' // ÂêÑÁ®ÆÁ¨¶Ëôü
//                                         r'[\u{1F680}-\u{1F6FF}]|' // ‰∫§ÈÄöÂ∑•ÂÖ∑Á¨¶Ëôü
//                                         r'[\u{2600}-\u{26FF}]|' // ÈõúÈ†ÖÁ¨¶Ëôü
//                                         r'[\u{2700}-\u{27BF}]', // Dingbats Ë®òËôü
//                                         unicode: true,
//                                       );

//                                       if (emojiRegex.hasMatch(content)) {
//                                         ScaffoldMessenger.of(context)
//                                             .showSnackBar(
//                                           SnackBar(
//                                             content: Text(
//                                               uiStrings['feedbackInvalid']
//                                                       ?[settings.locale] ??
//                                                   '‚ùóÔ∏èÂÖßÂÆπÂåÖÂê´‰∏çÊîØÊè¥ÁöÑÁ¨¶ËôüÔºàÂ¶Ç emoji Ë°®ÊÉÖÁ¨¶ËôüÔºâÔºåË´ãÁßªÈô§ÂæåÂÜçÁôºÈÄÅ„ÄÇ',
//                                               style: TextStyle(
//                                                 fontFamily: settings.fontFamily,
//                                                 fontSize: settings.fontSize,
//                                               ),
//                                             ),
//                                             duration:
//                                                 Duration(milliseconds: 1500),
//                                           ),
//                                         );
//                                         return;
//                                       }

//                                       _isSending.value = true;

//                                       // Áï∂Âú∞Á≥ªÁµ±ÊôÇÈñìÔºàÂÆåÊï¥Ê†ºÂºèÔºâ
//                                       final now = DateTime.now();
//                                       final formattedTime =
//                                           DateFormat('yyyy-MM-dd HH:mm:ss')
//                                               .format(now);

//                                       final timezoneOffset = now.timeZoneOffset;
//                                       final timezoneString = timezoneOffset
//                                               .isNegative
//                                           ? '-${timezoneOffset.inHours.abs().toString().padLeft(2, '0')}:${(timezoneOffset.inMinutes.abs() % 60).toString().padLeft(2, '0')}'
//                                           : '+${timezoneOffset.inHours.toString().padLeft(2, '0')}:${(timezoneOffset.inMinutes % 60).toString().padLeft(2, '0')}';

//                                       final timezoneName = now.timeZoneName;

//                                       final deviceTimeString =
//                                           '$formattedTime GMT$timezoneString ($timezoneName)';

//                                       final formattedDate =
//                                           DateFormat('yyyy-MM-dd').format(now);

//                                       // Âπ≥Âè∞Ë≥áË®ä
//                                       final platform = kIsWeb
//                                           ? 'Web'
//                                           : Theme.of(context).platform.name;

//                                       // Ë™ûË®Ä
//                                       final locale = settings.locale;

//                                       // Web ÁöÑ UserAgent
//                                       String userAgent = '';
//                                       if (kIsWeb) {
//                                         userAgent =
//                                             'Web Browser'; // ÁÆÄÂçïÊ†áËÆ∞ÊòØWebÁ´ØÔºåÊó†ÈúÄËÆøÈóÆhtml.window
//                                       }

//                                       // ÁµÑË£ùÂÆåÊï¥Ë®äÊÅØ
//                                       final fullMessage = '''
// $content

// ‚Äî‚Äî‚Äî
// Platform: $platform ${kIsWeb ? '(Web)' : ''}
// Locale: $locale
// ${userAgent.isNotEmpty ? 'UserAgent: $userAgent\n' : ''}Device Local Time (User\'s timezone): $deviceTimeString
// ''';
//                                       try {
//                                         final response = await http.post(
//                                           Uri.parse(
//                                               'https://formsubmit.co/f9d9312f748905d64423c6ce18bb285a'),
//                                           headers: {
//                                             'Content-Type':
//                                                 'application/x-www-form-urlencoded'
//                                           },
//                                           body: {
//                                             '_subject':
//                                                 'YsWords Feedback ($formattedDate)',
//                                             'message': fullMessage,
//                                             '_template': 'table',
//                                             '_honey': '',
//                                             '_captcha': 'false',
//                                           },
//                                         );
//                                         if (response.statusCode == 200) {
//                                           ScaffoldMessenger.of(context)
//                                               .showSnackBar(
//                                             SnackBar(
//                                               content: Text(
//                                                 uiStrings['feedbackSuccess']
//                                                         ?[settings.locale] ??
//                                                     '‚úÖ Feedback sent. Thank you!',
//                                                 style: TextStyle(
//                                                   fontFamily:
//                                                       settings.fontFamily,
//                                                   fontSize: settings.fontSize,
//                                                 ),
//                                               ),
//                                               duration:
//                                                   Duration(milliseconds: 1500),
//                                             ),
//                                           );
//                                           _feedbackController.clear();
//                                         } else {
//                                           ScaffoldMessenger.of(context)
//                                               .showSnackBar(
//                                             SnackBar(
//                                               content: Text(
//                                                 uiStrings['feedbackFailure']
//                                                         ?[settings.locale] ??
//                                                     '‚ùå Failed to send. Please try again.',
//                                                 style: TextStyle(
//                                                   fontFamily:
//                                                       settings.fontFamily,
//                                                   fontSize: settings.fontSize,
//                                                 ),
//                                               ),
//                                               duration:
//                                                   Duration(milliseconds: 1500),
//                                             ),
//                                           );
//                                         }
//                                       } catch (_) {
//                                         ScaffoldMessenger.of(context)
//                                             .showSnackBar(
//                                           SnackBar(
//                                             content: Text(
//                                               uiStrings['feedbackFailure']
//                                                       ?[settings.locale] ??
//                                                   '‚ùå Failed to send. Please try again.',
//                                               style: TextStyle(
//                                                 fontFamily: settings.fontFamily,
//                                                 fontSize: settings.fontSize,
//                                               ),
//                                             ),
//                                             duration:
//                                                 Duration(milliseconds: 1500),
//                                           ),
//                                         );
//                                       } finally {
//                                         _isSending.value = false;
//                                       }
//                                     },
//                             );
//                           },
//                         ),
//                       )
//                     ],
//                   ),
//                 ),
//               ),
            
            ],
          );
        },
      ),
    );
  }
}


================================================================================
FILE: pages/books_page.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:yswords/models/book.dart';
import 'package:yswords/models/chapter.dart';
import 'package:yswords/providers/main_provider.dart';
import 'package:provider/provider.dart';
import 'package:scroll_to_index/scroll_to_index.dart';
import 'package:yswords/constants/book_groups.dart'
    show oldTestamentBooks, newTestamentBooks;
import 'package:yswords/constants/ui_strings.dart';
import 'package:yswords/models/app_settings.dart';
import 'package:yswords/widgets/localized_back_button.dart';
import 'package:yswords/utils/version_mapper.dart' show toEnglish;

class BooksPage extends StatefulWidget {
  final int chapterIdx;
  final String bookIdx;
  const BooksPage({super.key, required this.chapterIdx, required this.bookIdx});

  @override
  State<BooksPage> createState() => _BooksPageState();
}

class _BooksPageState extends State<BooksPage> {
  final AutoScrollController _autoScrollController = AutoScrollController();
  Book? currentBook;
  bool showOldTestament = true;
  bool hasOldTestament = false;
  bool hasNewTestament = false;
  bool _initialScrollDone = false;

  Map<String, bool> expandStatus = {};
  @override
  void initState() {
    super.initState();
    final mainProvider = Provider.of<MainProvider>(context, listen: false);

    // Map displayed titles back to English keys (ÊîØÊåÅÁÆÄ / ÁπÅ / Ëã±)
    final bookTitlesEng = mainProvider.books
        .map<String>((b) => toEnglish(b.title) ?? b.title)
        .toSet();

    hasOldTestament = bookTitlesEng.any(
      (b) => oldTestamentBooks.contains(b),
    );
    hasNewTestament = bookTitlesEng.any(
      (b) => newTestamentBooks.contains(b),
    );

    // Default to OT if available; show NT only when no OT exists
    showOldTestament = hasOldTestament;

    // All start collapsed
    for (var book in mainProvider.books) {
      expandStatus[book.title] = false;
    }

    // Auto‚Äëexpand the current book (but only when a bookIdx was passed in)
    if (widget.bookIdx.isNotEmpty && expandStatus.containsKey(widget.bookIdx)) {
      expandStatus[widget.bookIdx] = true;
    }

    // **Scroll (but do not expand) to the book passed in via widget.bookIdx**
    final verseBook = widget.bookIdx;
    // if that book actually exists in our list...
    final bookEntry =
        mainProvider.books.firstWhereOrNull((b) => b.title == verseBook);
    if (bookEntry != null) {
      // show the correct side (OT/NT)
      showOldTestament = _isOldTestament(bookEntry.title);
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!_initialScrollDone) {
          final filtered = mainProvider.books
              .where((b) => showOldTestament
                  ? _isOldTestament(b.title)
                  : !_isOldTestament(b.title))
              .toList();
          final idx = filtered.indexWhere((b) => b.title == bookEntry.title);
          if (idx != -1) {
            // Scroll to the book index
            Future.microtask(() {
              if (mounted) {
                _autoScrollController.scrollToIndex(
                  idx,
                  preferPosition: AutoScrollPosition.begin,
                  duration: const Duration(milliseconds: 10),
                );
              }
            });
          }
          _initialScrollDone = true;
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final settings = Provider.of<AppSettings>(context);

    return Consumer<MainProvider>(
      builder: (context, mainProvider, child) {
        final books = mainProvider.books;
        final filteredBooks = books.where((book) {
          return showOldTestament
              ? _isOldTestament(book.title)
              : !_isOldTestament(book.title);
        }).toList();

        return Scaffold(
          appBar: AppBar(
            leading: const LocalizedBackButton(),
            title: Text(
                uiStrings['bibleBooks']?[settings.locale] ?? 'Bible Books'),
          ),
          body: Column(
            children: [
              if (hasOldTestament && hasNewTestament)
                Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      if (hasOldTestament)
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 4),
                          child: TextButton(
                            onPressed: () {
                              setState(() {
                                showOldTestament = true;
                                expandStatus.updateAll((key, _) => false);
                              });
                              _autoScrollController.scrollToIndex(
                                0,
                                preferPosition: AutoScrollPosition.begin,
                                duration: const Duration(milliseconds: 10),
                              );
                            },
                            style: TextButton.styleFrom(
                              backgroundColor: showOldTestament
                                  ? Theme.of(context).colorScheme.primary
                                  : Theme.of(context).colorScheme.surface,
                              foregroundColor: showOldTestament
                                  ? Theme.of(context).colorScheme.onPrimary
                                  : Theme.of(context).colorScheme.onSurface,
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(25),
                              ),
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 20, vertical: 10),
                            ),
                            child: Text(
                              uiStrings['oldTestament']?[settings.locale] ??
                                  'Old Testament',
                              style: TextStyle(
                                fontSize: settings.fontSize,
                                fontFamily: settings.fontFamily,
                              ),
                            ),
                          ),
                        ),
                      if (hasNewTestament)
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 4),
                          child: TextButton(
                            onPressed: () {
                              setState(() {
                                showOldTestament = false;
                                expandStatus.updateAll((key, _) => false);
                              });
                              _autoScrollController.scrollToIndex(
                                0,
                                preferPosition: AutoScrollPosition.begin,
                                duration: const Duration(milliseconds: 10),
                              );
                            },
                            style: TextButton.styleFrom(
                              backgroundColor: !showOldTestament
                                  ? Theme.of(context).colorScheme.primary
                                  : Theme.of(context).colorScheme.surface,
                              foregroundColor: !showOldTestament
                                  ? Theme.of(context).colorScheme.onPrimary
                                  : Theme.of(context).colorScheme.onSurface,
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(25),
                              ),
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 20, vertical: 10),
                            ),
                            child: Text(
                              uiStrings['newTestament']?[settings.locale] ??
                                  'New Testament',
                              style: TextStyle(
                                  fontSize: settings.fontSize,
                                  fontFamily: settings.fontFamily),
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
              Expanded(
                child: ListView.builder(
                  itemCount: filteredBooks.length,
                  physics: const BouncingScrollPhysics(),
                  controller: _autoScrollController,
                  itemBuilder: (context, index) {
                    Book book = filteredBooks[index];
                    return AutoScrollTag(
                      key: ValueKey(index),
                      controller: _autoScrollController,
                      index: index,
                      child: Container(
                        decoration: expandStatus[book.title] == true
                            ? null
                            : BoxDecoration(
                                border: Border(
                                  bottom: BorderSide(
                                    color: Theme.of(context).dividerColor,
                                    width: 0.3,
                                  ),
                                ),
                              ),
                        child: Theme(
                          data: Theme.of(context).copyWith(
                            expansionTileTheme: ExpansionTileThemeData(
                              expansionAnimationStyle: AnimationStyle(
                                  // duration: Duration(milliseconds: 1050),
                                  ),
                            ),
                          ),
                          child: ExpansionTile(
                            title: Text(
                              book.title,
                              style: TextStyle(
                                  fontSize: settings.fontSize,
                                  fontFamily: settings.fontFamily),
                            ),
                            initiallyExpanded:
                                expandStatus[book.title] ?? false,
                            maintainState: true,
                            onExpansionChanged: (expanded) {
                              setState(() {
                                expandStatus[book.title] = expanded;
                              });
                            },
                            children: [
                              Wrap(
                                alignment: WrapAlignment.start,
                                children:
                                    List.generate(book.chapters.length, (i) {
                                  Chapter chapter = book.chapters[i];
                                  return Padding(
                                    padding: const EdgeInsets.all(4),
                                    child: SizedBox(
                                      height: 55,
                                      width: 55,
                                      child: Card(
                                        color: (chapter.title ==
                                                    widget.chapterIdx &&
                                                widget.bookIdx == book.title)
                                            ? Theme.of(context)
                                                .colorScheme
                                                .primaryContainer
                                            : null,
                                        elevation: 1,
                                        shape: RoundedRectangleBorder(
                                          borderRadius:
                                              BorderRadius.circular(7.5),
                                        ),
                                        child: InkWell(
                                          borderRadius:
                                              BorderRadius.circular(7.5),
                                          onTap: () {
                                            final firstVerseOfChapter =
                                                mainProvider.verses.firstWhere(
                                              (v) =>
                                                  v.book == book.title &&
                                                  v.chapter == chapter.title,
                                            );
                                            mainProvider.setCurrentChapter(
                                              book: book.title,
                                              chapter: chapter.title,
                                            );
                                            mainProvider.updateCurrentVerse(
                                                verse: firstVerseOfChapter);
                                            mainProvider.itemScrollController
                                                .jumpTo(index: 0);
                                            Get.back();
                                          },
                                          child: Center(
                                            child: Text(
                                              chapter.title.toString(),
                                              style: TextStyle(
                                                  fontSize:
                                                      settings.fontSize * 0.9,
                                                  fontFamily:
                                                      settings.fontFamily),
                                            ),
                                          ),
                                        ),
                                      ),
                                    ),
                                  );
                                }),
                              ),
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  bool _isOldTestament(String displayedTitle) {
    final en = toEnglish(displayedTitle) ?? displayedTitle;
    return oldTestamentBooks.contains(en);
  }
}


================================================================================
FILE: pages/search_page.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:yswords/models/verse.dart';
import 'package:yswords/providers/main_provider.dart';
import 'package:yswords/utils/format_searched_text.dart';
import 'package:provider/provider.dart';
import 'dart:async';
import 'package:yswords/constants/ui_strings.dart';
import 'package:yswords/models/app_settings.dart';
import 'package:yswords/widgets/localized_back_button.dart';
import 'package:flutter/services.dart';

class SearchPage extends StatefulWidget {
  const SearchPage({super.key});

  @override
  State<SearchPage> createState() => _SearchPageState();
}

class _SearchPageState extends State<SearchPage> {
  // Controllers and list for managing search functionality
  final ScrollController _scrollController = ScrollController();
  final TextEditingController _textEditingController = TextEditingController();
  final List<Verse> _results = [];

  bool searchPerformed = false;
  bool searchAll = true;
  Map<String, int> bookCounts = {};
  String? filterBook;

  // Method to perform the search
  Future<void> search() async {
    setState(() {
      _results.clear();
      bookCounts.clear();
      searchPerformed = false;
    });

    final mainProvider = Provider.of<MainProvider>(context, listen: false);
    final verses = mainProvider.verses;
    final source = filterBook != null
        ? verses.where((v) => v.book == filterBook)
        : searchAll
            ? verses
            : verses.where((v) => v.book == mainProvider.currentBook);

    final notePattern  = RegExp(r'<note:[^>]*>');
    final bracePattern = RegExp(r'\{[^}]*\}');

    for (var verse in source) {
      // sanitize out notes and braces before searching
      final sanitized = verse.text
          .replaceAll(notePattern, '')
          .replaceAll(bracePattern, '')
          .trim();
      final textNorm = sanitized.replaceAll(" ", "").toLowerCase();
      final queryNorm =
          _textEditingController.text.trim().replaceAll(" ", "").toLowerCase();
      if (textNorm.contains(queryNorm)) {
        if (!_results.contains(verse)) {
          _results.add(verse);
          bookCounts[verse.book] = (bookCounts[verse.book] ?? 0) + 1;
        }
      }
    }

    final bookOrder = { for (var i = 0; i < mainProvider.books.length; i++) mainProvider.books[i].title: i };

    _results.sort((a, b) {
      final orderA = bookOrder[a.book] ?? 9999;
      final orderB = bookOrder[b.book] ?? 9999;
      if (orderA != orderB) return orderA.compareTo(orderB);
      if (a.chapter != b.chapter) return a.chapter.compareTo(b.chapter);
      return a.verse.compareTo(b.verse);
    });

    final sortedEntries = bookCounts.entries.toList()
      ..sort((a, b) {
        final orderA = bookOrder[a.key] ?? 9999;
        final orderB = bookOrder[b.key] ?? 9999;
        return orderA.compareTo(orderB);
      });
    bookCounts = { for (var e in sortedEntries) e.key: e.value };

    setState(() {
      searchPerformed = true;
    });
  }

  @override
  Widget build(BuildContext context) {
    final settings = Provider.of<AppSettings>(context);
    // Patterns to strip out notes and curly annotations
    final notePattern  = RegExp(r'<note:[^>]*>');
    final bracePattern = RegExp(r'\{[^}]*\}');
    return Scaffold(
        appBar: AppBar(
          leading: const LocalizedBackButton(),
          // Search input field in the app bar
          title: TextField(
            autofocus: true,
            controller: _textEditingController,
            style: TextStyle(fontSize: settings.fontSize),
            decoration: InputDecoration(
              border: InputBorder.none,
              hintText: uiStrings['search']?[settings.locale] ?? 'Search',
            ),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[0-9a-zA-Z\u4E00-\u9FFF ]')),
            ],
            onChanged: (text) {
              setState(() {
                if (text.trim().isEmpty) {
                  searchAll = true;
                  filterBook = null;
                }
              });
            },
            onSubmitted: (s) async {
              if (s.trim().isEmpty) {
                setState(() {
                  searchAll = true;
                  filterBook = null;
                });
              }
              await search();
              _scrollController.jumpTo(0.0);
            },
            textInputAction: TextInputAction.search,
          ),
          actions: [
            PopupMenuButton<Object>(
              tooltip: uiStrings['showMenu']?[settings.locale] ?? 'Show menu',
              icon: const Icon(Icons.filter_list),
              onSelected: (value) async {
                setState(() {
                  _results.clear();
                  bookCounts.clear();
                  if (value is bool) {
                    searchAll = value;
                    filterBook = null;
                  } else if (value is String) {
                    filterBook = value;
                    searchAll = false;
                  }
                });
                // Immediately perform search and scroll to top
                await search();
                _scrollController.jumpTo(0.0);
              },
              itemBuilder: (_) {
                // base scope items
                final items = <PopupMenuEntry<Object>>[
                  PopupMenuItem<bool>(
                      value: false,
                      child: Text(uiStrings['searchCurrentBook']?[settings.locale] ?? 'Search Current Book', style: TextStyle(fontSize: settings.fontSize))),
                  PopupMenuItem<bool>(
                      value: true,
                      child: Text(uiStrings['searchEntireBible']?[settings.locale] ?? 'Search Entire Bible', style: TextStyle(fontSize: settings.fontSize))),
                ];
                // divider
                items.add(const PopupMenuDivider());
                // use bookCounts for per-book counts
                bookCounts.forEach((book, count) {
                  items.add(
                    PopupMenuItem<String>(
                      value: book,
                      child: Text('$book ($count)', style: TextStyle(fontSize: settings.fontSize)),
                    ),
                  );
                });
                return items;
              },
            ),
            // Clear search button when there's input
            if (_textEditingController.text.isNotEmpty)
              IconButton(
                onPressed: () {
                  setState(() {
                    _textEditingController.clear();
                    FocusScope.of(context).unfocus(); // ÂÖ≥Èó≠ÈîÆÁõò
                    _results.clear();
                    bookCounts.clear();
                    searchPerformed = false;
                    searchAll = true; // ‚úÖ ÊÅ¢Â§ç‰∏∫Êï¥Êú¨ÊêúÁ¥¢
                    filterBook = null; // ‚úÖ Ê∏ÖÈô§‰π¶Âç∑Á≠õÈÄâ
                  });
                },
                icon: const Icon(Icons.close_rounded),
              ),
          ],
        ),
        body: Column(
          children: [
            if (_results.isNotEmpty)
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: GestureDetector(
                  onTap: () {
                    if (bookCounts.isNotEmpty) {
                      showDialog(
                        context: context,
                        builder: (context) {
                          return AlertDialog(
                            title: Text(uiStrings['bibleBooks']
                                    ?[settings.locale] ??
                                'Bible Books',
                              style: TextStyle(fontSize: settings.fontSize),
                            ),
                            content: SingleChildScrollView(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: bookCounts.entries
                                    .map((e) => Text('${e.key} (${e.value})', style: TextStyle(fontSize: settings.fontSize)))
                                    .toList(),
                              ),
                            ),
                            actions: [
                              TextButton(
                                onPressed: () => Navigator.of(context).pop(),
                                child: Text(uiStrings['ok']?[settings.locale] ?? 'OK', style: TextStyle(fontSize: settings.fontSize)),
                              ),
                            ],
                          );
                        },
                      );
                    }
                  },
                  child: Text(
                    ((uiStrings['searchResultCount']?[settings.locale] ??
                                    'Total {count} matches, grouped by book:')
                                .replaceAll(
                                    '{count}', _results.length.toString()) +
                            bookCounts.entries
                                .take(3)
                                .map((e) => '${e.key}(${e.value})')
                                .join('Ôºå') +
                            (bookCounts.length > 3 ? '...' : '')) +
                        (bookCounts.length > 3
                            ? '\n${uiStrings['viewMoreBooksHint']?[settings.locale] ?? ''}'
                            : ''),
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      fontWeight: FontWeight.w500,
                      fontSize: settings.fontSize,
                    ),
                  ),
                ),
              ),
            Expanded(
              child: _results.isEmpty && searchPerformed
                  ? Center(
                      child: Padding(
                        padding: const EdgeInsets.all(20.0),
                        child: Text(
                          uiStrings['noResults']?[settings.locale] ??
                              'No results found',
                          style: Theme.of(context)
                              .textTheme
                              .bodyLarge
                              ?.copyWith(
                                fontWeight: FontWeight.w500,
                                color: Theme.of(context).colorScheme.outline,
                              )
                              .copyWith(fontSize: settings.fontSize),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    )
                  : ListView.builder(
                      controller: _scrollController,
                      physics: const BouncingScrollPhysics(),
                      itemCount: _results.length,
                      itemBuilder: (context, index) {
                        final verse = _results[index];
                        return DecoratedBox(
                          decoration: BoxDecoration(
                            border: Border(
                              bottom: BorderSide(
                                  color: Theme.of(context).hoverColor),
                            ),
                          ),
                          child: ListTile(
                            onTap: () {
                              final mainProv = Provider.of<MainProvider>(
                                  context,
                                  listen: false);
                              mainProv.setCurrentChapter(
                                  book: verse.book, chapter: verse.chapter);
                              mainProv.updateCurrentVerse(verse: verse);
                              Get.back();
                              Future.delayed(const Duration(milliseconds: 1), () {
                                final chapterVerses = mainProv.verses
                                    .where((v) => v.book == verse.book && v.chapter == verse.chapter)
                                    .toList();
                                chapterVerses.sort((a, b) => a.verse.compareTo(b.verse)); // Ensure order
                                final relIdx = chapterVerses.indexWhere((v) => v.verse == verse.verse);
                                if (relIdx < 0) return;
                                mainProv.jumpToIndex(index: relIdx);
                                mainProv.setHighlightIndex(relIdx);
                                Future.delayed(const Duration(milliseconds: 800), () {
                                  mainProv.clearHighlightIndex();
                                });
                              });
                            },
                            // Sanitize verse text: remove <note:‚Ä¶> and {...}, leave [‚Ä¶]
                            title: Builder(
                              builder: (context) {
                                final sanitized = verse.text
                                    .replaceAll(notePattern, '')
                                    .replaceAll(bracePattern, '')
                                    .trim();
                                return formatSearchText(
                                  input: sanitized,
                                  text: _textEditingController.text.trim(),
                                  context: context,
                                );
                              },
                            ),
                            subtitle: Text(
                                '${verse.book} ${verse.chapter}:${verse.verse}',
                                style: TextStyle(fontSize: settings.fontSize * 0.85),
                            ),
                          ),
                        );
                      },
                    ),
            )
          ],
        ));
  }
}


================================================================================
FILE: services/read_last_index.dart
================================================================================
import 'package:shared_preferences/shared_preferences.dart';

// Class responsible for reading the last saved index from SharedPreference

class ReadLastIndex {
  // Static method to execute the reading process
  static Future<int?> execute() async {
    // Obtain an instance of SharedPreference
    final SharedPreferences sharedPreferences =
        await SharedPreferences.getInstance();

    // Retrieve the last saved index from SharedPreferences
    return sharedPreferences.getInt('index');
  }
}


================================================================================
FILE: services/fetch_books.dart
================================================================================
import 'package:yswords/models/book.dart';
import 'package:yswords/models/chapter.dart';
import 'package:yswords/providers/main_provider.dart';
import 'package:yswords/models/verse.dart';
import 'package:yswords/models/app_settings.dart';

const List<String> standardBookOrder = [
  'Genesis', 'Exodus', 'Leviticus', 'Numbers', 'Deuteronomy',
  'Joshua', 'Judges', 'Ruth',
  '1 Samuel', '2 Samuel', '1 Kings', '2 Kings',
  '1 Chronicles', '2 Chronicles', 'Ezra', 'Nehemiah', 'Esther',
  'Job', 'Psalms', 'Proverbs', 'Ecclesiastes', 'Song of Solomon',
  'Isaiah', 'Jeremiah', 'Lamentations', 'Ezekiel', 'Daniel',
  'Hosea', 'Joel', 'Amos', 'Obadiah', 'Jonah', 'Micah',
  'Nahum', 'Habakkuk', 'Zephaniah', 'Haggai', 'Zechariah', 'Malachi',
  'Matthew', 'Mark', 'Luke', 'John', 'Acts',
  'Romans', '1 Corinthians', '2 Corinthians', 'Galatians', 'Ephesians',
  'Philippians', 'Colossians', '1 Thessalonians', '2 Thessalonians',
  '1 Timothy', '2 Timothy', 'Titus', 'Philemon',
  'Hebrews', 'James', '1 Peter', '2 Peter',
  '1 John', '2 John', '3 John', 'Jude', 'Revelation',
  // Add Chinese Simplified and Traditional names afterwards if needed separately.
];

const Map<String, String> bookNameToEnglish = {
  // Genesis
  'Genesis': 'Genesis', 'Âàõ‰∏ñÁ∫™': 'Genesis', 'Ââµ‰∏ñÁ¥Ä': 'Genesis',
  // Exodus
  'Exodus': 'Exodus', 'Âá∫ÂüÉÂèäËÆ∞': 'Exodus', 'Âá∫ÂüÉÂèäË®ò': 'Exodus',
  // Leviticus
  'Leviticus': 'Leviticus', 'Âà©Êú™ËÆ∞': 'Leviticus', 'Âà©Êú™Ë®ò': 'Leviticus',
  // Numbers
  'Numbers': 'Numbers', 'Ê∞ëÊï∞ËÆ∞': 'Numbers', 'Ê∞ëÊï∏Ë®ò': 'Numbers',
  // Deuteronomy
  'Deuteronomy': 'Deuteronomy', 'Áî≥ÂëΩËÆ∞': 'Deuteronomy', 'Áî≥ÂëΩË®ò': 'Deuteronomy',
  // Joshua
  'Joshua': 'Joshua', 'Á∫¶‰π¶‰∫öËÆ∞': 'Joshua', 'Á¥ÑÊõ∏‰∫ûË®ò': 'Joshua',
  // Judges
  'Judges': 'Judges', 'Â£´Â∏àËÆ∞': 'Judges', 'Â£´Â∏´Ë®ò': 'Judges',
  // Ruth
  'Ruth': 'Ruth', 'Ë∑ØÂæóËÆ∞': 'Ruth', 'Ë∑ØÂæóË®ò': 'Ruth',
  // 1 Samuel
  '1 Samuel': '1 Samuel', 'ÊííÊØçËÄ≥ËÆ∞‰∏ä': '1 Samuel', 'ÊííÊØçËÄ≥Ë®ò‰∏ä': '1 Samuel',
  // 2 Samuel
  '2 Samuel': '2 Samuel', 'ÊííÊØçËÄ≥ËÆ∞‰∏ã': '2 Samuel', 'ÊííÊØçËÄ≥Ë®ò‰∏ã': '2 Samuel',
  // 1 Kings
  '1 Kings': '1 Kings', 'ÂàóÁéãÁ∫™‰∏ä': '1 Kings', 'ÂàóÁéãÁ¥Ä‰∏ä': '1 Kings',
  // 2 Kings
  '2 Kings': '2 Kings', 'ÂàóÁéãÁ∫™‰∏ã': '2 Kings', 'ÂàóÁéãÁ¥Ä‰∏ã': '2 Kings',
  // 1 Chronicles
  '1 Chronicles': '1 Chronicles', 'ÂéÜ‰ª£Âøó‰∏ä': '1 Chronicles', 'Ê≠∑‰ª£Âøó‰∏ä': '1 Chronicles',
  // 2 Chronicles
  '2 Chronicles': '2 Chronicles', 'ÂéÜ‰ª£Âøó‰∏ã': '2 Chronicles', 'Ê≠∑‰ª£Âøó‰∏ã': '2 Chronicles',
  // Ezra
  'Ezra': 'Ezra', '‰ª•ÊñØÊãâËÆ∞': 'Ezra', '‰ª•ÊñØÊãâË®ò': 'Ezra',
  // Nehemiah
  'Nehemiah': 'Nehemiah', 'Â∞ºÂ∏åÁ±≥ËÆ∞': 'Nehemiah', 'Â∞ºÂ∏åÁ±≥Ë®ò': 'Nehemiah',
  // Esther
  'Esther': 'Esther', '‰ª•ÊñØÂ∏ñËÆ∞': 'Esther', '‰ª•ÊñØÂ∏ñË®ò': 'Esther',
  // Job
  'Job': 'Job', 'Á∫¶‰ºØËÆ∞': 'Job', 'Á¥Ñ‰ºØË®ò': 'Job',
  // Psalms
  'Psalms': 'Psalms', 'ËØóÁØá': 'Psalms', 'Ë©©ÁØá': 'Psalms',
  // Proverbs
  'Proverbs': 'Proverbs', 'ÁÆ¥Ë®Ä': 'Proverbs',
  // Ecclesiastes
  'Ecclesiastes': 'Ecclesiastes', '‰º†ÈÅì‰π¶': 'Ecclesiastes', 'ÂÇ≥ÈÅìÊõ∏': 'Ecclesiastes',
  // Song of Solomon
  'Song of Solomon': 'Song of Solomon', 'ÈõÖÊ≠å': 'Song of Solomon',
  // Isaiah
  'Isaiah': 'Isaiah', '‰ª•Ëµõ‰∫ö‰π¶': 'Isaiah', '‰ª•Ë≥Ω‰∫ûÊõ∏': 'Isaiah',
  // Jeremiah
  'Jeremiah': 'Jeremiah', 'ËÄ∂Âà©Á±≥‰π¶': 'Jeremiah', 'ËÄ∂Âà©Á±≥Êõ∏': 'Jeremiah',
  // Lamentations
  'Lamentations': 'Lamentations', 'ËÄ∂Âà©Á±≥ÂìÄÊ≠å': 'Lamentations', 
  // Ezekiel
  'Ezekiel': 'Ezekiel', '‰ª•Ë•øÁªì‰π¶': 'Ezekiel', '‰ª•Ë•øÁµêÊõ∏': 'Ezekiel',
  // Daniel
  'Daniel': 'Daniel', '‰ΩÜ‰ª•ÁêÜ‰π¶': 'Daniel', '‰ΩÜ‰ª•ÁêÜÊõ∏': 'Daniel',
  // Hosea
  'Hosea': 'Hosea', '‰ΩïË•øÈòø‰π¶': 'Hosea', '‰ΩïË•øÈòøÊõ∏': 'Hosea',
  // Joel
  'Joel': 'Joel', 'Á∫¶Áè•‰π¶': 'Joel', 'Á¥ÑÁè•Êõ∏': 'Joel',
  // Amos
  'Amos': 'Amos', 'ÈòøÊë©Âè∏‰π¶': 'Amos', 'ÈòøÊë©Âè∏Êõ∏': 'Amos',
  // Obadiah
  'Obadiah': 'Obadiah', '‰øÑÂ∑¥Â∫ï‰∫ö‰π¶': 'Obadiah', '‰øÑÂ∑¥Â∫ï‰∫ûÊõ∏': 'Obadiah',
  // Jonah
  'Jonah': 'Jonah', 'Á∫¶Êãø‰π¶': 'Jonah', 'Á¥ÑÊãøÊõ∏': 'Jonah',
  // Micah
  'Micah': 'Micah', 'Âº•Ëø¶‰π¶': 'Micah', 'ÂΩåËø¶Êõ∏': 'Micah',
  // Nahum
  'Nahum': 'Nahum', 'ÈÇ£È∏ø‰π¶': 'Nahum', 'ÈÇ£È¥ªÊõ∏': 'Nahum',
  // Habakkuk
  'Habakkuk': 'Habakkuk', 'ÂìàÂ∑¥Ë∞∑‰π¶': 'Habakkuk', 'ÂìàÂ∑¥Ë∞∑Êõ∏': 'Habakkuk',
  // Zephaniah
  'Zephaniah': 'Zephaniah', 'Ë•øÁï™ÈõÖ‰π¶': 'Zephaniah', 'Ë•øÁï™ÈõÖÊõ∏': 'Zephaniah',
  // Haggai
  'Haggai': 'Haggai', 'ÂìàËØ•‰π¶': 'Haggai', 'ÂìàË©≤Êõ∏': 'Haggai',
  // Zechariah
  'Zechariah': 'Zechariah', 'ÊííËø¶Âà©‰∫ö‰π¶': 'Zechariah', 'ÊííËø¶Âà©‰∫ûÊõ∏': 'Zechariah',
  // Malachi
  'Malachi': 'Malachi', 'ÁéõÊãâÂü∫‰π¶': 'Malachi', 'Áë™ÊãâÂü∫Êõ∏': 'Malachi',
  // Matthew
  'Matthew': 'Matthew', 'È©¨Â§™Á¶èÈü≥': 'Matthew', 'È¶¨Â§™Á¶èÈü≥': 'Matthew',
  // Mark
  'Mark': 'Mark', 'È©¨ÂèØÁ¶èÈü≥': 'Mark', 'È¶¨ÂèØÁ¶èÈü≥': 'Mark',
  // Luke
  'Luke': 'Luke', 'Ë∑ØÂä†Á¶èÈü≥': 'Luke',
  // John
  'John': 'John', 'Á∫¶Áø∞Á¶èÈü≥': 'John', 'Á¥ÑÁø∞Á¶èÈü≥': 'John',
  // Acts
  'Acts': 'Acts', '‰ΩøÂæíË°å‰º†': 'Acts', '‰ΩøÂæíË°åÂÇ≥': 'Acts',
  // Romans
  'Romans': 'Romans', 'ÁΩóÈ©¨‰π¶': 'Romans', 'ÁæÖÈ¶¨Êõ∏': 'Romans',
  // 1 Corinthians
  '1 Corinthians': '1 Corinthians', 'Âì•ÊûóÂ§öÂâç‰π¶': '1 Corinthians', 'Âì•ÊûóÂ§öÂâçÊõ∏': '1 Corinthians',
  // 2 Corinthians
  '2 Corinthians': '2 Corinthians', 'Âì•ÊûóÂ§öÂêé‰π¶': '2 Corinthians', 'Âì•ÊûóÂ§öÂæåÊõ∏': '2 Corinthians',
  // Galatians
  'Galatians': 'Galatians', 'Âä†ÊãâÂ§™‰π¶': 'Galatians', 'Âä†ÊãâÂ§™Êõ∏': 'Galatians',
  // Ephesians
  'Ephesians': 'Ephesians', '‰ª•ÂºóÊâÄ‰π¶': 'Ephesians', '‰ª•ÂºóÊâÄÊõ∏': 'Ephesians',
  // Philippians
  'Philippians': 'Philippians', 'ËÖìÁ´ãÊØî‰π¶': 'Philippians', 'ËÖìÁ´ãÊØîÊõ∏': 'Philippians',
  // Colossians
  'Colossians': 'Colossians', 'Ê≠åÁΩóË•ø‰π¶': 'Colossians', 'Ê≠åÁæÖË•øÊõ∏': 'Colossians',
  // 1 Thessalonians
  '1 Thessalonians': '1 Thessalonians', 'Â∏ñÊííÁΩóÂ∞ºËø¶Ââç‰π¶': '1 Thessalonians', 'Â∏ñÊííÁæÖÂ∞ºËø¶ÂâçÊõ∏': '1 Thessalonians',
  // 2 Thessalonians
  '2 Thessalonians': '2 Thessalonians', 'Â∏ñÊííÁΩóÂ∞ºËø¶Âêé‰π¶': '2 Thessalonians', 'Â∏ñÊííÁæÖÂ∞ºËø¶ÂæåÊõ∏': '2 Thessalonians',
  // 1 Timothy
  '1 Timothy': '1 Timothy', 'ÊèêÊë©Â§™Ââç‰π¶': '1 Timothy', 'ÊèêÊë©Â§™ÂâçÊõ∏': '1 Timothy',
  // 2 Timothy
  '2 Timothy': '2 Timothy', 'ÊèêÊë©Â§™Âêé‰π¶': '2 Timothy', 'ÊèêÊë©Â§™ÂæåÊõ∏': '2 Timothy',
  // Titus
  'Titus': 'Titus', 'ÊèêÂ§ö‰π¶': 'Titus', 'ÊèêÂ§öÊõ∏': 'Titus',
  // Philemon
  'Philemon': 'Philemon', 'ËÖìÂà©Èó®‰π¶': 'Philemon', 'ËÖìÂà©ÈñÄÊõ∏': 'Philemon',
  // Hebrews
  'Hebrews': 'Hebrews', 'Â∏å‰ºØÊù•‰π¶': 'Hebrews', 'Â∏å‰ºØ‰æÜÊõ∏': 'Hebrews',
  // James
  'James': 'James', 'ÈõÖÂêÑ‰π¶': 'James', 'ÈõÖÂêÑÊõ∏': 'James',
  // 1 Peter
  '1 Peter': '1 Peter', 'ÂΩºÂæóÂâç‰π¶': '1 Peter', 'ÂΩºÂæóÂâçÊõ∏': '1 Peter',
  // 2 Peter
  '2 Peter': '2 Peter', 'ÂΩºÂæóÂêé‰π¶': '2 Peter', 'ÂΩºÂæóÂæåÊõ∏': '2 Peter',
  // 1 John
  '1 John': '1 John', 'Á∫¶Áø∞‰∏Ä‰π¶': '1 John', 'Á¥ÑÁø∞‰∏ÄÊõ∏': '1 John',
  // 2 John
  '2 John': '2 John', 'Á∫¶Áø∞‰∫å‰π¶': '2 John', 'Á¥ÑÁø∞‰∫åÊõ∏': '2 John',
  // 3 John
  '3 John': '3 John', 'Á∫¶Áø∞‰∏â‰π¶': '3 John', 'Á¥ÑÁø∞‰∏âÊõ∏': '3 John',
  // Jude
  'Jude': 'Jude', 'ÁäπÂ§ß‰π¶': 'Jude', 'Áå∂Â§ßÊõ∏': 'Jude',
  // Revelation
  'Revelation': 'Revelation', 'ÂêØÁ§∫ÂΩï': 'Revelation', 'ÂïüÁ§∫ÈåÑ': 'Revelation',
};

// Class repsonsible for fetching books based on the provided verses

class FetchBooks {
  // Static method to execute the fetching process
  static Future<void> execute({required MainProvider mainProvider, required AppSettings settings}) async {
    if (!settings.allowUpdates) {
      return; 
    }
    List<Verse> verses = mainProvider.verses;

    // Collect unique book titles mapped to English
    final Set<String> _seen = {};
    final List<String> foundBookTitles = [];
    for (final v in verses) {
      final englishBook = bookNameToEnglish[v.book] ?? v.book;
      if (_seen.add(englishBook)) foundBookTitles.add(englishBook);
    }

    // Sort book titles according to standard biblical order
    final List<String> bookTitles = [
      ...standardBookOrder.where((b) => foundBookTitles.contains(b))
    ];

    // Iterate through each unique book title to organize chapters and verses
    for (var bookTitle in bookTitles) {
      // Filter verses based on the current book title mapped to English
      List<Verse> availableVerses =
          verses.where((v) => (bookNameToEnglish[v.book] ?? v.book) == bookTitle).toList();

      // Collect unique chapter numbers *and* sort them so UI lists 1, 2, 3‚Ä¶ in order.
      List<int> availableChapters = availableVerses
          .map((e) => e.chapter)
          .toSet()
          .toList()
        ..sort();

      List<Chapter> chapters = [];

      // Iterate through each unique chapter number to organize verses
      for (var element in availableChapters) {
        // Create a Chapter object for each unique chapter
        Chapter chapter = Chapter(
          title: element,
          verses: (availableVerses.where((v) => v.chapter == element).toList()
            ..sort((a, b) => a.verse.compareTo(b.verse))),
        );

        chapters.add(chapter);
      }

      // Use the localized book name from the first verse for display
      final localizedBookName = availableVerses.first.book;
      Book book = Book(title: localizedBookName, chapters: chapters);

      // Add the created Book to the mainProvider's ist of books
      mainProvider.addBook(book: book);
    }
  }

}


================================================================================
FILE: services/save_current_index.dart
================================================================================
import 'package:shared_preferences/shared_preferences.dart';

// Class responsible for saving the current index to SharedPreferences

class SaveCurrentIndex {
  // Static method to execute the saving process
  static Future<void> execute({required int index}) async {
    // Obtain an instance of SharedPreferences
    final SharedPreferences sharedPreferences =
        await SharedPreferences.getInstance();

    // Save the curent index to SharedPreference
    sharedPreferences.setInt('index', index);
  }

  static Future<void> saveVersion(String version) async {
    final prefs = await SharedPreferences.getInstance();
    prefs.setString('version', version);
  }

  static Future<String?> readVersion() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString('version');
  }
}


================================================================================
FILE: services/fetch_verses.dart
================================================================================
import 'dart:convert';

import 'package:flutter/services.dart';
import 'package:yswords/models/verse.dart';
import 'package:yswords/providers/main_provider.dart';
import 'package:yswords/models/app_settings.dart';

class FetchVerses {
  static Future<void> execute(
      {required MainProvider mainProvider,
      required AppSettings settings}) async {
    final version = mainProvider.currentVersion;
    final path = 'assets/${version.toLowerCase()}.json';

    if (settings.allowUpdates == false) {
      await loadLocalOnly(mainProvider: mainProvider);
      return;
    }

    mainProvider.setVerses([]);
    mainProvider.setBooks([]);

    // Load & parse the JSON from assets, supporting both list and passages-map formats
    String jsonString = await rootBundle.loadString(path);
    final dynamic decoded = json.decode(jsonString);

    // Build a flat list of maps with book, chapter, verse, text
    List<Map<String, dynamic>> rawList;
    if (decoded is List) {
      rawList = List<Map<String, dynamic>>.from(decoded);
    } else if (decoded is Map<String, dynamic> && decoded['passages'] != null) {
      final passages = decoded['passages'] as Map<String, dynamic>;
      final bookName = decoded['abbreviation'] ?? decoded['book'] ?? '';
      rawList = passages.entries.map((e) {
        final parts = e.key.split(':');
        return {
          'book': bookName,
          'chapter': parts[0],
          'verse': parts[1],
          'text': e.value + '\n',
        };
      }).toList();
    } else {
      throw Exception('Unsupported verse JSON format');
    }

    // Filter out entries where verse is non-numeric (e.g. Psalm titles)
    rawList = rawList.where((m) => int.tryParse(m['verse']?.toString() ?? '') != null).toList();

    // Map into Verse objects, skipping any parse errors
    final verses = <Verse>[];
    for (final m in rawList) {
      try {
        verses.add(Verse.fromJson(m));
      } catch (_) {
        // skip invalid entries
      }
    }

    // Sort in canonical order
    const bookOrder = [
      'Genesis','Exodus','Leviticus','Numbers','Deuteronomy','Joshua',
      'Judges','Ruth','1 Samuel','2 Samuel','1 Kings','2 Kings',
      '1 Chronicles','2 Chronicles','Ezra','Nehemiah','Esther','Job',
      'Psalms','Proverbs','Ecclesiastes','Song of Solomon','Isaiah',
      'Jeremiah','Lamentations','Ezekiel','Daniel','Hosea','Joel',
      'Amos','Obadiah','Jonah','Micah','Nahum','Habakkuk',
      'Zechariah','Haggai','Malachi','Matthew','Mark','Luke','John',
      'Acts','Romans','1 Corinthians','2 Corinthians','Galatians',
      'Ephesians','Philippians','Colossians','1 Thessalonians',
      '2 Thessalonians','1 Timothy','2 Timothy','Titus','Philemon',
      'Hebrews','James','1 Peter','2 Peter','1 John','2 John',
      '3 John','Jude','Revelation'
    ];
    verses.sort((a, b) {
      final ai = bookOrder.indexOf(a.book);
      final bi = bookOrder.indexOf(b.book);
      if (ai != bi) return ai.compareTo(bi);
      final c = a.chapter.compareTo(b.chapter);
      return c != 0 ? c : a.verse.compareTo(b.verse);
    });

    // Update provider
    mainProvider.setVerses(verses);
  }

  static Future<void> loadLocalOnly(
      {required MainProvider mainProvider}) async {
    try {
      // Determine the asset file based on the current version
      final version = mainProvider.currentVersion.toLowerCase();
      final path = 'assets/$version.json';

      // Clear existing verses and books
      mainProvider.setVerses([]);
      mainProvider.setBooks([]);

      // Load & parse the JSON from assets, supporting both list and passages-map formats
      String jsonString = await rootBundle.loadString(path);
      final dynamic decoded = json.decode(jsonString);

      // Build a flat list of maps with book, chapter, verse, text
      List<Map<String, dynamic>> rawList;
      if (decoded is List) {
        rawList = List<Map<String, dynamic>>.from(decoded);
      } else if (decoded is Map<String, dynamic> && decoded['passages'] != null) {
        final passages = decoded['passages'] as Map<String, dynamic>;
        final bookName = decoded['abbreviation'] ?? decoded['book'] ?? '';
        rawList = passages.entries.map((e) {
          final parts = e.key.split(':');
          return {
            'book': bookName,
            'chapter': parts[0],
            'verse': parts[1],
            'text': e.value + '\n',
          };
        }).toList();
      } else {
        throw Exception('Unsupported verse JSON format');
      }

      // Filter out entries where verse is non-numeric (e.g. Psalm titles)
      rawList = rawList.where((m) => int.tryParse(m['verse']?.toString() ?? '') != null).toList();

      // Map into Verse objects, skipping any parse errors
      final verses = <Verse>[];
      for (final m in rawList) {
        try {
          verses.add(Verse.fromJson(m));
        } catch (_) {
          // skip invalid entries
        }
      }

      // Sort in canonical order
      const bookOrder = [
        'Genesis','Exodus','Leviticus','Numbers','Deuteronomy','Joshua',
        'Judges','Ruth','1 Samuel','2 Samuel','1 Kings','2 Kings',
        '1 Chronicles','2 Chronicles','Ezra','Nehemiah','Esther','Job',
        'Psalms','Proverbs','Ecclesiastes','Song of Solomon','Isaiah',
        'Jeremiah','Lamentations','Ezekiel','Daniel','Hosea','Joel',
        'Amos','Obadiah','Jonah','Micah','Nahum','Habakkuk',
        'Zechariah','Haggai','Malachi','Matthew','Mark','Luke','John',
        'Acts','Romans','1 Corinthians','2 Corinthians','Galatians',
        'Ephesians','Philippians','Colossians','1 Thessalonians',
        '2 Thessalonians','1 Timothy','2 Timothy','Titus','Philemon',
        'Hebrews','James','1 Peter','2 Peter','1 John','2 John',
        '3 John','Jude','Revelation'
      ];
      verses.sort((a, b) {
        final ai = bookOrder.indexOf(a.book);
        final bi = bookOrder.indexOf(b.book);
        if (ai != bi) return ai.compareTo(bi);
        final c = a.chapter.compareTo(b.chapter);
        return c != 0 ? c : a.verse.compareTo(b.verse);
      });

      // Update provider
      mainProvider.setVerses(verses);
      print('Loaded local $path verses.');
    } catch (e) {
      print(
          'Error loading local verses for version ${mainProvider.currentVersion}: $e');
    }
  }

  static Future<bool> testLoadLocal() async {
    final List<String> assetPaths = [
      'assets/kjv.json',
      'assets/leb.json',
      'assets/cuvs-yhwh.json',
      'assets/cuvs-yhwh-tr.json',
      'assets/biblexg.json',
      'assets/biblexg-tr.json',
      'assets/app_icon.png',
      'assets/loading.png',
      'assets/fonts/Microsoft Yahei.ttf',
      'assets/fonts/Roboto-VariableFont_wdth,wght.ttf',
    ];

    try {
      for (final path in assetPaths) {
        await rootBundle.load(path);
      }
      return true;
    } catch (e) {
      print('Local resource not fully ready: $e');
      return false;
    }
  }
}


================================================================================
FILE: widgets/localized_back_button.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:yswords/constants/ui_strings.dart';
import 'package:yswords/models/app_settings.dart';

class LocalizedBackButton extends StatelessWidget {
  const LocalizedBackButton({super.key});

  @override
  Widget build(BuildContext context) {
    final settings = Provider.of<AppSettings>(context, listen: false);
    return IconButton(
      icon: const Icon(Icons.arrow_back),
      tooltip: uiStrings['back']?[settings.locale] ?? 'Back',
      onPressed: () => Navigator.of(context).maybePop(),
    );
  }
}

================================================================================
FILE: widgets/verse_widget.dart
================================================================================
import 'package:flutter/material.dart';
import 'package:yswords/models/verse.dart';
import 'package:yswords/providers/main_provider.dart';
import 'package:provider/provider.dart';
import 'package:yswords/models/app_settings.dart';
import 'package:yswords/utils/clipboard_helper.dart';

class VerseWidget extends StatelessWidget {
  final Verse verse;
  final int index;
  const VerseWidget({super.key, required this.verse, required this.index});

  @override
  Widget build(BuildContext context) {
    return Consumer2<MainProvider, AppSettings>(
      builder: (context, mainProvider, settings, child) {
        final isSelected = mainProvider.isSelected(verse);
        final isHighlighted = mainProvider.highlightIndex == index;

        // Prepare regex and spans for verse text with annotations
        final squarePattern = RegExp(r'\[([^\]]+)\]');
        final bracePattern = RegExp(r'\{([^}]+)\}');
        final notePattern = RegExp(r'<note:([^>]+)>');
        final combinedPattern = RegExp(r'(\{[^}]+\}|\[[^\]]+\]|<note:[^>]+>)');
        final original = verse.text.replaceAll('\n', '');
        final raw = original.trim();
        final parts = raw
            .splitMapJoin(
              combinedPattern,
              onMatch: (m) => '||${m[0]}||',
              onNonMatch: (n) => n,
            )
            .split('||');
        final spans = <InlineSpan>[];
        final skipNoteIcons =
            bracePattern.hasMatch(original) && notePattern.hasMatch(original);
        // Verse number span
        spans.add(WidgetSpan(
          child: GestureDetector(
            onTap: () async {
              final toCopy = '${verse.verse} ${verse.text.trim()}';
              await ClipboardHelper.copyText(toCopy);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Copied verse ${verse.verse}')),
              );
            },
            child: Text(
              '${verse.verse} ',
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                    fontSize: settings.fontSize,
                    height: settings.lineSpacing,
                    fontWeight: FontWeight.w500,
                    fontFamily: settings.fontFamily,
                    color: isSelected
                        ? Theme.of(context).colorScheme.onPrimaryContainer
                        : Theme.of(context).colorScheme.primary,
                  ),
            ),
          ),
        ));
        // Build text and badge spans
        String? lastPart;
        for (var part in parts) {
          // Skip <note:...> if lastPart was exactly a brace and this part is *only* a note
          final isNoteOnly =
              part.trim().startsWith('<note:') && part.trim().endsWith('>');
          final wasBraceOnly = lastPart != null &&
              lastPart.trim().startsWith('{') &&
              lastPart.trim().endsWith('}');
          if (isNoteOnly && wasBraceOnly) {
            lastPart = part;
            continue;
          }
          if (bracePattern.hasMatch(part)) {
            final annotation = bracePattern.firstMatch(part)!.group(1)!;
            final isDark = Theme.of(context).brightness == Brightness.dark;
            final bgColor = isDark
                ? Theme.of(context).colorScheme.secondary.withOpacity(0.2)
                : Theme.of(context).colorScheme.secondary.withOpacity(0.3);
            spans.add(WidgetSpan(
              alignment: PlaceholderAlignment.middle,
              child: GestureDetector(
                onTap: () {
                  final verseText = verse.text.replaceAll('\n', '');
                  final braceFull = '{$annotation}';
                  final braceIndex = verseText.indexOf(braceFull);
                  String? extractedNote;
                  if (braceIndex != -1) {
                    final afterBrace =
                        verseText.substring(braceIndex + braceFull.length);
                    // Look for the next <note:...> tag, allowing for whitespace or punctuation in between, but no braces/brackets
                    final nextAnnotation = RegExp(r'''^([\s.,;:"‚Äú‚Äù'"‚Äù]*)<note:([^>]+)>''')
                        .firstMatch(afterBrace);
                    if (nextAnnotation != null) {
                      extractedNote = nextAnnotation.group(2);
                    }
                  }
                  showDialog(
                    context: context,
                    builder: (_) => AlertDialog(
                      title: Text('Note'),
                      content: Text(extractedNote ?? annotation),
                      actions: [
                        TextButton(
                          onPressed: () => Navigator.of(context).pop(),
                          child: Text('Close'),
                        )
                      ],
                    ),
                  );
                },
                child: Container(
                  padding: EdgeInsets.symmetric(horizontal: 6, vertical: 3),
                  margin: EdgeInsets.symmetric(horizontal: 2),
                  decoration: BoxDecoration(
                    color: bgColor,
                    border: Border.all(
                      color: isDark ? Colors.teal.shade200 : Colors.teal,
                      width: 1,
                    ),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Builder(
                    builder: (_) {
                      final spans = <InlineSpan>[];
                      final regex = RegExp(r'\[([^\[\]]+)\]');
                      final matches = regex.allMatches(annotation);

                      if (matches.isNotEmpty) {
                        int lastEnd = 0;
                        for (final match in matches) {
                          if (match.start > lastEnd) {
                            spans.add(TextSpan(
                              text: annotation.substring(lastEnd, match.start),
                              style: TextStyle(
                                fontSize: settings.fontSize * 0.1,
                                fontFamily: settings.fontFamily,
                                height: settings.lineSpacing,
                                color: isSelected
                                    ? Theme.of(context)
                                        .colorScheme
                                        .onPrimaryContainer
                                    : Theme.of(context)
                                        .textTheme
                                        .bodyLarge
                                        ?.color,
                              ),
                            ));
                          }
                          final text = match.group(1)!;
                          spans.add(TextSpan(
                            text: text,
                            style: TextStyle(
                              fontSize: settings.fontSize,
                              fontFamily: settings.fontFamily,
                              height: settings.lineSpacing,
                              decoration: TextDecoration.underline,
                              decorationStyle: TextDecorationStyle.dotted,
                              decorationColor:
                                  Theme.of(context).colorScheme.primary,
                              decorationThickness: 2.0,
                              color: isSelected
                                  ? Theme.of(context)
                                      .colorScheme
                                      .onPrimaryContainer
                                  : Theme.of(context)
                                      .textTheme
                                      .bodyLarge
                                      ?.color,
                            ),
                          ));
                          lastEnd = match.end;
                        }
                        if (lastEnd < annotation.length) {
                          spans.add(TextSpan(
                            text: annotation.substring(lastEnd),
                            style: TextStyle(
                              fontSize: settings.fontSize * 0.85,
                              fontFamily: settings.fontFamily,
                              height: settings.lineSpacing,
                              color: isSelected
                                  ? Theme.of(context)
                                      .colorScheme
                                      .onPrimaryContainer
                                  : Theme.of(context)
                                      .textTheme
                                      .bodyLarge
                                      ?.color,
                            ),
                          ));
                        }

                        return RichText(text: TextSpan(children: spans));
                      } else {
                        return Text(
                          annotation,
                          style: TextStyle(
                            fontSize: settings.fontSize * 0.85,
                            fontFamily: settings.fontFamily,
                            height: settings.lineSpacing,
                            color: isSelected
                                ? Theme.of(context)
                                    .colorScheme
                                    .onPrimaryContainer
                                : (isDark
                                    ? Colors.white
                                    : Theme.of(context)
                                        .textTheme
                                        .bodyLarge
                                        ?.color),
                          ),
                        );
                      }
                    },
                  ),
                ),
              ),
            ));
            // handled as a brace
            lastPart = part;
            continue;
          }
          if (squarePattern.hasMatch(part)) {
            final annotation = squarePattern.firstMatch(part)!.group(1)!;
            spans.add(TextSpan(
              text: annotation,
              style: TextStyle(
                fontSize: settings.fontSize,
                fontFamily: settings.fontFamily,
                height: settings.lineSpacing,
                decoration: TextDecoration.underline,
                decorationStyle: TextDecorationStyle.dotted,
                decorationColor: Theme.of(context).colorScheme.primary,
                decorationThickness: 2.0,
                color: isSelected
                    ? Theme.of(context).colorScheme.onPrimaryContainer
                    : Theme.of(context).textTheme.bodyLarge?.color,
              ),
            ));
            lastPart = part;
            continue;
          }
          if (notePattern.hasMatch(part) &&
              !bracePattern.hasMatch(part) &&
              !(part.trim().startsWith('<note:') &&
                  part.trim().endsWith('>') &&
                  (lastPart?.trim().endsWith('}') ?? false))) {
            if (skipNoteIcons) {
              lastPart = part;
              continue;
            }
            final note = notePattern.firstMatch(part)!.group(1)!;
            final isDark = Theme.of(context).brightness == Brightness.dark;
            final bgColor = isDark
                ? Theme.of(context).colorScheme.secondary.withOpacity(0.2)
                : Theme.of(context).colorScheme.secondary.withOpacity(0.3);
            spans.add(WidgetSpan(
              alignment: PlaceholderAlignment.middle,
              child: GestureDetector(
                onTap: () {
                  showDialog(
                    context: context,
                    builder: (_) => AlertDialog(
                      title: Text('Note'),
                      content: Text(note),
                      actions: [
                        TextButton(
                          onPressed: () => Navigator.of(context).pop(),
                          child: Text('Close'),
                        )
                      ],
                    ),
                  );
                },
                child: Padding(
                  padding: const EdgeInsets.only(left: 2, bottom: 1.5),
                  child: Icon(
                    Icons.menu_book,
                    size: settings.fontSize * 0.75,
                    color: Theme.of(context).iconTheme.color?.withOpacity(0.5),
                  ),
                ),
              ),
            ));
            lastPart = part;
            continue;
          }
          {
            spans.add(TextSpan(
              text: part,
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                    fontSize: settings.fontSize,
                    height: settings.lineSpacing,
                    color: isSelected
                        ? Theme.of(context).colorScheme.onPrimaryContainer
                        : Theme.of(context).textTheme.bodyLarge?.color,
                    fontFamily: settings.fontFamily,
                  ),
            ));
            lastPart = part;
          }
        }

        return Material(
          color: Colors.white.withOpacity(0.01),
          clipBehavior: Clip.hardEdge,
          child: InkWell(
            highlightColor: Colors.transparent,
            splashColor: Colors.transparent,
            onTap: () {
              mainProvider.toggleVerse(verse: verse);
            },
            child: Column(
              crossAxisAlignment: settings.readingModeCentered
                  ? CrossAxisAlignment.center
                  : CrossAxisAlignment.start,
              children: [
                if (settings.readingModeCentered &&
                    verse.isParagraphStart == true)
                  const SizedBox(height: 16),
                Container(
                  width: double.infinity,
                  color: isSelected
                      ? Theme.of(context).colorScheme.primaryContainer
                      : isHighlighted
                          ? Theme.of(context)
                              .colorScheme
                              .secondary
                              .withOpacity(0.3)
                          : Colors.transparent,
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  child: RichText(
                    textAlign: settings.readingModeCentered
                        ? TextAlign.center
                        : TextAlign.start,
                    text: TextSpan(
                      children: spans,
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

